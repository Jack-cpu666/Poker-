<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎰 Royal Blackjack 3D - Premium Casino Experience</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --royal-gold: #FFD700;
            --royal-gold-dark: #B8860B;
            --casino-red: #DC143C;
            --casino-green: #228B22;
            --deep-blue: #000080;
            --platinum: #E5E4E2;
            --dark-bg: #0a0a0a;
            --panel-bg: rgba(0, 0, 0, 0.9);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --shadow-gold: rgba(255, 215, 0, 0.5);
            --text-gold: #FFD700;
            --text-white: #FFFFFF;
            --text-dark: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: var(--text-white);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 215, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(220, 20, 60, 0.2) 0%, transparent 50%);
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #canvas {
            display: block;
            cursor: grab;
            flex: 1;
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.3));
        }

        #canvas:active { cursor: grabbing; }

        /* Premium Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: all 1s ease-out;
        }

        .logo-container {
            position: relative;
            margin-bottom: 40px;
        }

        .loading-logo {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            animation: logoGlow 3s ease-in-out infinite;
            text-align: center;
            position: relative;
        }

        .loading-logo::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: logoHalo 4s linear infinite;
            z-index: -1;
        }

        @keyframes logoGlow {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.05); filter: brightness(1.2); }
        }

        @keyframes logoHalo {
            0% { transform: rotate(0deg) scale(1); opacity: 0.3; }
            50% { transform: rotate(180deg) scale(1.1); opacity: 0.6; }
            100% { transform: rotate(360deg) scale(1); opacity: 0.3; }
        }

        .loading-spinner {
            width: 100px;
            height: 100px;
            border: 6px solid rgba(255, 215, 0, 0.2);
            border-top: 6px solid var(--royal-gold);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
            position: relative;
        }

        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 4px solid transparent;
            border-top: 4px solid rgba(255, 215, 0, 0.6);
            border-radius: 50%;
            animation: spin 1s linear infinite reverse;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.4rem;
            color: var(--text-white);
            opacity: 0.9;
            text-align: center;
            font-weight: 300;
            letter-spacing: 2px;
            animation: textPulse 2s ease-in-out infinite;
        }

        @keyframes textPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Premium UI Overlay System */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            position: absolute;
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border-radius: 20px;
            padding: 25px;
            color: var(--text-white);
            pointer-events: auto;
            border: 2px solid var(--royal-gold);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 30px rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(20px);
            transition: all 0.4s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--royal-gold), transparent, var(--royal-gold));
            border-radius: 20px;
            z-index: -1;
            opacity: 0.7;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Enhanced Menu Panel */
        .menu-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            min-width: 500px;
            max-width: 90vw;
            z-index: 9000;
        }

        .menu-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            animation: titleShine 3s ease-in-out infinite;
            text-align: center;
            position: relative;
        }

        .menu-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--royal-gold), transparent);
            animation: underlineGlow 2s ease-in-out infinite;
        }

        @keyframes titleShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes underlineGlow {
            0%, 100% { opacity: 0.5; transform: translateX(-50%) scaleX(1); }
            50% { opacity: 1; transform: translateX(-50%) scaleX(1.2); }
        }

        .menu-section {
            margin-bottom: 25px;
            padding: 20px;
            background: var(--glass-bg);
            border-radius: 15px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .menu-section:hover {
            border-color: var(--royal-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }

        .menu-section h3 {
            color: var(--royal-gold);
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
            text-align: center;
            position: relative;
        }

        .menu-section h3::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 1px;
            background: var(--royal-gold);
        }

        /* Premium Button Styles */
        .premium-button {
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark));
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            color: var(--text-dark);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 16px rgba(255, 215, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            min-width: 140px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Montserrat', sans-serif;
        }

        .premium-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .premium-button:hover::before {
            left: 100%;
        }

        .premium-button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 24px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .premium-button:active {
            transform: translateY(-1px);
        }

        .premium-button:disabled {
            background: linear-gradient(45deg, #666, #888);
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
            box-shadow: none;
        }

        /* Specialized Button Colors */
        .button-hit {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .button-stand {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .button-double {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .button-split {
            background: linear-gradient(45deg, #6f42c1, #5a32a3);
            color: white;
        }

        .button-surrender {
            background: linear-gradient(45deg, #fd7e14, #e66100);
            color: white;
        }

        /* Enhanced Game HUD */
        .game-hud {
            top: 30px;
            left: 30px;
            max-width: 380px;
            z-index: 800;
            max-height: 50vh;
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px 16px;
            background: var(--glass-bg);
            border-radius: 10px;
            border-left: 4px solid var(--royal-gold);
            transition: all 0.3s ease;
        }

        .hud-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .hud-label {
            font-weight: 500;
            color: var(--royal-gold);
            font-size: 0.95rem;
        }

        .hud-value {
            font-weight: 700;
            color: var(--text-white);
            font-size: 1rem;
            font-family: 'Cinzel', serif;
        }

        /* Enhanced Dealer Area */
        .dealer-area {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            min-width: 350px;
            backdrop-filter: blur(20px);
            z-index: 700;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .dealer-title {
            font-family: 'Cinzel', serif;
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--royal-gold);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dealer-hand {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .dealer-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-white);
            font-family: 'Cinzel', serif;
        }

        /* Enhanced Action Panels */
        .actions-panel {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 600;
        }

        /* Enhanced Betting Controls */
        .bet-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .bet-label {
            color: var(--royal-gold);
            font-weight: 600;
            font-size: 1.1rem;
            white-space: nowrap;
        }

        .bet-input {
            padding: 12px;
            border: 2px solid var(--royal-gold);
            border-radius: 10px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 1.1rem;
            text-align: center;
            width: 120px;
            min-width: 100px;
            font-family: 'Cinzel', serif;
            font-weight: 600;
        }

        .bet-input:focus {
            outline: none;
            border-color: var(--royal-gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        .bet-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .bet-button {
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark));
            color: var(--text-dark);
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .bet-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }

        /* Enhanced Chat Panel */
        .chat-panel {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 350px;
            max-height: 60vh;
            min-height: 300px;
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
            z-index: 500;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--royal-gold);
            flex-shrink: 0;
        }

        .chat-title {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            color: var(--royal-gold);
            font-size: 1.2rem;
        }

        .chat-toggle {
            background: none;
            border: 2px solid var(--royal-gold);
            color: var(--royal-gold);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .chat-toggle:hover {
            background: var(--royal-gold);
            color: var(--text-dark);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            background: var(--glass-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            min-height: 180px;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-left: 3px solid var(--royal-gold);
            animation: slideInChat 0.4s ease-out;
            word-wrap: break-word;
            font-size: 0.9rem;
        }

        @keyframes slideInChat {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chat-player-name {
            font-weight: 700;
            margin-right: 8px;
        }

        .chat-timestamp {
            font-size: 0.8rem;
            opacity: 0.7;
            float: right;
        }

        .chat-input-container {
            display: flex;
            gap: 12px;
            margin-top: auto;
            flex-shrink: 0;
        }

        .chat-input-container input {
            flex: 1;
            padding: 12px;
            border: 2px solid var(--royal-gold);
            border-radius: 10px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 0.9rem;
        }

        .chat-input-container input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Enhanced Player Hands Display */
        .player-hands {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 400;
        }

        .player-hand {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(10, 10, 30, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            min-width: 220px;
            position: relative;
            transition: all 0.4s ease;
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
        }

        .player-hand.current-player {
            border-color: #ff4757;
            box-shadow: 
                0 0 40px rgba(255, 71, 87, 0.6),
                0 15px 30px rgba(0, 0, 0, 0.4);
            animation: currentPlayerPulse 2s ease-in-out infinite;
        }

        @keyframes currentPlayerPulse {
            0%, 100% { 
                box-shadow: 
                    0 0 40px rgba(255, 71, 87, 0.6),
                    0 15px 30px rgba(0, 0, 0, 0.4);
            }
            50% { 
                box-shadow: 
                    0 0 60px rgba(255, 71, 87, 0.9),
                    0 20px 40px rgba(0, 0, 0, 0.5);
            }
        }

        .player-hand.blackjack {
            border-color: var(--royal-gold);
            animation: blackjackGlow 1.5s ease-in-out infinite;
        }

        @keyframes blackjackGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.5),
                    0 15px 30px rgba(0, 0, 0, 0.4);
            }
            50% { 
                box-shadow: 
                    0 0 50px rgba(255, 215, 0, 0.8),
                    0 20px 40px rgba(0, 0, 0, 0.5);
            }
        }

        .player-hand.bust {
            opacity: 0.5;
            filter: grayscale(70%);
            border-color: #666;
        }

        .player-name {
            font-weight: 700;
            color: var(--text-white);
            margin-bottom: 12px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
        }

        .player-money {
            color: var(--royal-gold);
            font-weight: 700;
            font-family: 'Cinzel', serif;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .hand-info {
            margin: 8px 0;
            font-size: 0.95rem;
        }

        .hand-cards {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .card-mini {
            width: 35px;
            height: 48px;
            background: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: black;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: transform 0.2s ease;
        }

        .card-mini:hover {
            transform: translateY(-2px);
        }

        .card-mini.red { color: #dc3545; }
        .card-mini.back { 
            background: linear-gradient(135deg, #1e3a8a, #3b82f6); 
            color: white; 
        }

        /* Enhanced Form Elements */
        input, select {
            padding: 15px 20px;
            border: 2px solid var(--royal-gold);
            border-radius: 12px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: 'Montserrat', sans-serif;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--royal-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Enhanced Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { 
            background: rgba(255, 255, 255, 0.1); 
            border-radius: 5px; 
        }
        ::-webkit-scrollbar-thumb { 
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark)); 
            border-radius: 5px; 
            transition: background 0.3s ease;
        }
        ::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(45deg, var(--royal-gold-dark), var(--royal-gold)); 
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.6s ease-out; }
        .fade-out { animation: fadeOut 0.6s ease-out; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Enhanced Notifications */
        .notification-container {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            pointer-events: none;
        }

        .notification {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.95), rgba(32, 201, 151, 0.95));
            color: var(--text-white);
            padding: 18px 25px;
            border-radius: 12px;
            border-left: 4px solid var(--royal-gold);
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: slideInNotification 0.6s ease-out;
            min-width: 280px;
            max-width: 400px;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            font-weight: 500;
        }

        .notification.error {
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.95), rgba(255, 107, 107, 0.95));
        }

        .notification.warning {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.95), rgba(255, 235, 59, 0.95));
            color: var(--text-dark);
        }

        .notification.info {
            background: linear-gradient(135deg, rgba(25, 25, 112, 0.95), rgba(108, 92, 231, 0.95));
        }

        @keyframes slideInNotification {
            from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Enhanced Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(26, 26, 46, 0.98));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 35px;
            max-width: 85vw;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(25px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--royal-gold);
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--royal-gold);
        }

        .modal-close {
            background: none;
            border: 2px solid #dc3545;
            color: #dc3545;
            border-radius: 8px;
            padding: 10px 18px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .modal-close:hover {
            background: #dc3545;
            color: var(--text-white);
            transform: scale(1.05);
        }

        /* Connection Status Enhanced */
        .connection-status {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .connection-status.connected {
            background: linear-gradient(45deg, rgba(40, 167, 69, 0.9), rgba(32, 201, 151, 0.9));
            color: white;
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .connection-status.disconnected {
            background: linear-gradient(45deg, rgba(220, 20, 60, 0.9), rgba(255, 107, 107, 0.9));
            color: white;
            border: 1px solid rgba(220, 20, 60, 0.5);
            animation: pulse 1s infinite;
        }

        .connection-status.connecting {
            background: linear-gradient(45deg, rgba(255, 193, 7, 0.9), rgba(255, 235, 59, 0.9));
            color: var(--text-dark);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        /* Mobile Responsiveness Enhanced */
        @media (max-width: 768px) {
            .menu-panel {
                min-width: 95vw;
                padding: 20px;
                max-height: 85vh;
            }

            .menu-title {
                font-size: 2.2rem;
            }

            .chat-panel {
                width: 95vw;
                max-height: 45vh;
                top: auto;
                bottom: 200px;
                left: 2.5vw;
                right: 2.5vw;
            }

            .actions-panel {
                bottom: 30px;
                gap: 12px;  
                padding: 0 15px;
            }

            .premium-button {
                padding: 12px 20px;
                font-size: 0.9rem;
                min-width: 110px;
            }

            .player-hands {
                bottom: 220px;
                gap: 15px;
                padding: 0 15px;
            }

            .player-hand {
                min-width: 180px;
                padding: 15px;
            }

            .dealer-area {
                min-width: 320px;
                padding: 20px;
            }

            .game-hud {
                max-width: 320px;
                max-height: 55vh;
            }

            .bet-controls {
                flex-direction: column;
                align-items: center;
                gap: 12px;
            }

            .loading-logo {
                font-size: 2.8rem;
            }
        }

        @media (max-width: 480px) {
            .menu-panel {
                min-width: 98vw;
                padding: 15px;
            }

            .premium-button {
                padding: 10px 18px;
                font-size: 0.85rem;
                min-width: 100px;
            }

            .chat-panel {
                max-height: 40vh;
            }

            .player-hand {
                min-width: 160px;
                padding: 12px;
            }

            .loading-logo {
                font-size: 2.2rem;
            }

            .dealer-title {
                font-size: 1.3rem;
            }

            .menu-title {
                font-size: 1.8rem;
            }
        }

        /* Floating Particles Effect */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.6) 0%, transparent 70%);
            border-radius: 50%;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            from {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            to {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="animated-bg"></div>

    <!-- Floating Particles -->
    <div class="floating-particles" id="particles"></div>

    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">Connecting...</div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="logo-container">
            <div class="loading-logo">
                🎰 ROYAL BLACKJACK 3D 🎰
            </div>
        </div>
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading premium casino experience...</div>
    </div>

    <!-- Main Game Container -->
    <div id="gameContainer">
        <canvas id="canvas"></canvas>

        <!-- UI Overlay -->
        <div class="ui-overlay">
            <!-- Main Menu -->
            <div id="menuPanel" class="ui-panel menu-panel hidden">
                <h1 class="menu-title">
                    🎰 ROYAL BLACKJACK 3D 🎰
                </h1>

                <div class="menu-section">
                    <h3>👤 Player Setup</h3>
                    <label for="playerName">Player Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your royal name" value="Royal Player" maxlength="20">
                </div>

                <div class="menu-section">
                    <h3>⚡ Quick Play</h3>
                    <button class="premium-button" onclick="createQuickRoom()" style="width: 100%; margin-bottom: 15px;">
                        🎯 Create Quick Room
                    </button>
                    <div style="display: flex; gap: 12px; margin-bottom: 15px;">
                        <input type="text" id="roomCodeInput" placeholder="Room Code" style="flex: 1; margin-bottom: 0;" maxlength="6">
                        <button class="premium-button" onclick="joinRoomFromInput()">🚪 Join</button>
                    </div>
                    <button class="premium-button" onclick="spectateRoomFromInput()" style="width: 100%;">
                        👁️ Spectate Room
                    </button>
                </div>

                <div class="menu-section">
                    <h3>🎪 Custom Game</h3>
                    <label for="roomName">Room Name (Optional):</label>
                    <input type="text" id="roomName" placeholder="Royal Casino Table" maxlength="30">
                    <button class="premium-button" onclick="createCustomRoom()" style="width: 100%; margin-top: 20px;">
                        🏛️ Create Custom Room
                    </button>
                </div>

                <div class="menu-section">
                    <h3>🏛️ Browse Rooms</h3>
                    <button class="premium-button" onclick="showRoomList()" style="width: 100%;">
                        🎲 Browse Public Rooms
                    </button>
                </div>
            </div>

            <!-- Room List Modal -->
            <div id="roomListModal" class="modal hidden">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2 class="modal-title">🏛️ Royal Gaming Rooms</h2>
                        <button class="modal-close" onclick="hideRoomList()">✕</button>
                    </div>
                    <div id="roomList" style="max-height: 60vh; overflow-y: auto;">
                        <div style="text-align: center; color: #ccc; padding: 30px;">
                            <div class="loading-spinner" style="margin: 0 auto 20px; width: 60px; height: 60px;"></div>
                            Loading royal rooms...
                        </div>
                    </div>
                    <div style="margin-top: 25px; text-align: center;">
                        <button class="premium-button" onclick="refreshRoomList()">🔄 Refresh</button>
                    </div>
                </div>
            </div>

            <!-- Game HUD -->
            <div id="gameHUD" class="ui-panel game-hud hidden">
                <div class="hud-item">
                    <span class="hud-label">🏠 Room:</span>
                    <span class="hud-value" id="currentRoomCodeDisplay">-</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">🎮 Phase:</span>
                    <span class="hud-value" id="phaseText">Waiting</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">💰 Balance:</span>
                    <span class="hud-value">$<span id="moneyAmount">0</span></span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">🃏 Hand #:</span>
                    <span class="hud-value" id="handNumber">0</span>
                </div>
                <div style="margin-top: 20px; display: flex; flex-direction: column; gap: 12px;">
                    <button class="premium-button" onclick="startGame()" id="startGameBtn" style="width: 100%;">
                        🚀 Start Game
                    </button>
                    <button class="premium-button button-surrender" onclick="leaveRoom()" id="leaveRoomBtn" style="width: 100%;">
                        🚪 Leave Room
                    </button>
                </div>
            </div>

            <!-- Dealer Area -->
            <div id="dealerArea" class="dealer-area hidden">
                <div class="dealer-title">🎩 ROYAL DEALER</div>
                <div class="dealer-hand" id="dealerHand"></div>
                <div class="dealer-value" id="dealerValue">Hidden</div>
            </div>

            <!-- Betting Controls -->
            <div id="betControls" class="actions-panel hidden">
                <div class="bet-controls">
                    <span class="bet-label">💰 Bet Amount:</span>
                    <div class="bet-buttons">
                        <button class="bet-button" onclick="setBetAmount(10)">$10</button>
                        <button class="bet-button" onclick="setBetAmount(25)">$25</button>
                        <button class="bet-button" onclick="setBetAmount(50)">$50</button>
                        <button class="bet-button" onclick="setBetAmount(100)">$100</button>
                        <button class="bet-button" onclick="setBetAmount(250)">$250</button>
                    </div>
                    <input type="number" id="betAmountInput" class="bet-input" min="10" max="500" value="25" step="5">
                    <button class="premium-button" onclick="placeBet()">💎 Place Bet</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div id="actionsPanel" class="actions-panel hidden">
                <button class="premium-button button-hit" onclick="playerAction('hit')" id="hitBtn">👆 Hit</button>
                <button class="premium-button button-stand" onclick="playerAction('stand')" id="standBtn">✋ Stand</button>
                <button class="premium-button button-double" onclick="playerAction('double_down')" id="doubleBtn">⚡ Double</button>
                <button class="premium-button button-split" onclick="playerAction('split')" id="splitBtn">✂️ Split</button>
                <button class="premium-button button-surrender" onclick="playerAction('surrender')" id="surrenderBtn">🏳️ Surrender</button>
            </div>

            <!-- Chat Panel -->
            <div id="chatPanel" class="chat-panel hidden">
                <div class="chat-header">
                    <h3 class="chat-title">💬 Royal Chat</h3>
                    <button class="chat-toggle" onclick="toggleChat()" id="chatToggle">−</button>
                </div>
                <div id="chatMessages"></div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Type royal message..."
                           onkeypress="handleChatKeyPress(event)" maxlength="200">
                    <button class="premium-button" onclick="sendChat()">Send</button>
                </div>
            </div>

            <!-- Player Hands Display -->
            <div id="playerHandsDisplay" class="player-hands hidden"></div>
        </div>
    </div>

    <!-- Notifications Container -->
    <div id="notificationContainer" class="notification-container"></div>

    <script>
        // Enhanced Game State Management
        let ws = null;
        let scene, camera, renderer;
        let blackjackTable, tableGroup;
        let playerPositions = [];
        let cardMaterials = {}, chipMaterials = {};
        let currentGameState = null;
        let isConnected = false;
        let isPlayerInGame = false;
        let myPlayerId = null;
        let currentRoomCode = null;
        let cameraAnimating = false;
        let isLoadingOrReconnecting = false;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000;

        let communityCardObjects = [];
        let playerCardObjects3D = {};
        let dealerCardObjects3D = [];
        let chipStackObjects = {};
        let particleSystem;
        let environmentLights = [];
        let soundEffects = {};

        let chatCollapsed = false;
        let connectionStatusEl;

        // Enhanced Logging with Timestamp
        function consoleLog(message, ...params) {
            const timestamp = new Date().toISOString();
            console.log(`[RoyalBlackjack] ${timestamp} - ${message}`, ...params);
        }

        function consoleError(message, ...params) {
            const timestamp = new Date().toISOString();
            console.error(`[RoyalBlackjack ERROR] ${timestamp} - ${message}`, ...params);
        }

        function consoleWarn(message, ...params) {
            const timestamp = new Date().toISOString();
            console.warn(`[RoyalBlackjack WARN] ${timestamp} - ${message}`, ...params);
        }

        // Enhanced Connection Status Management
        function updateConnectionStatus(status, message = '') {
            if (!connectionStatusEl) {
                connectionStatusEl = document.getElementById('connectionStatus');
            }
            if (!connectionStatusEl) return;

            connectionStatusEl.className = `connection-status ${status}`;

            switch(status) {
                case 'connected':
                    connectionStatusEl.textContent = '🟢 Connected';
                    break;
                case 'connecting':
                    connectionStatusEl.textContent = '🟡 Connecting...';
                    break;
                case 'disconnected':
                    connectionStatusEl.textContent = '🔴 Disconnected';
                    break;
                case 'reconnecting':
                    connectionStatusEl.textContent = `🟡 Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`;
                    break;
            }

            if (message) {
                connectionStatusEl.title = message;
            }
        }

        // Enhanced Three.js Initialization with Premium Graphics
        function initThreeJS() {
            consoleLog("Initializing premium 3D engine...");
            try {
                const canvas = document.getElementById('canvas');
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x0a0a1a, 20, 80);

                // Enhanced lighting setup
                setupPremiumLighting();

                // Camera with improved settings
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 15, 20);
                camera.lookAt(0, 0, 0);
                camera.userData = { 
                    targetRotationY: 0, 
                    targetDistance: 20, 
                    targetHeight: 15,
                    smoothness: 0.05 
                };

                // Enhanced renderer settings
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.4;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.physicallyCorrectLights = true;

                // Create premium casino environment
                createPremiumCasinoEnvironment();
                createLuxuryBlackjackTable();
                createPremiumCardMaterials();
                createLuxuryChipMaterials();
                addEnhancedMouseControls();
                createAdvancedParticleSystem();
                createFloatingParticles();

                animate();

                consoleLog("Premium 3D engine initialized successfully");
                return true;
            } catch (e) {
                consoleError("Error during 3D engine initialization:", e);
                showNotification("3D Engine Error. Please refresh the page.", "error", 10000);
                return false;
            }
        }

        function setupPremiumLighting() {
            // Ambient lighting for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Main directional light with enhanced shadows
            const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
            mainLight.position.set(20, 30, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 200;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            mainLight.shadow.bias = -0.0005;
            mainLight.shadow.radius = 4;
            scene.add(mainLight);

            // Dramatic table spotlight
            const tableSpotlight = new THREE.SpotLight(0xffd700, 3.0, 50, Math.PI / 4, 0.3, 2);
            tableSpotlight.position.set(0, 25, 0);
            tableSpotlight.target.position.set(0, 0, 0);
            tableSpotlight.castShadow = true;
            tableSpotlight.shadow.mapSize.width = 2048;
            tableSpotlight.shadow.mapSize.height = 2048;
            scene.add(tableSpotlight);
            scene.add(tableSpotlight.target);

            // Rim lighting for atmosphere
            const rimLight1 = new THREE.DirectionalLight(0x4169e1, 0.8);
            rimLight1.position.set(-15, 8, -15);
            scene.add(rimLight1);

            const rimLight2 = new THREE.DirectionalLight(0xdc143c, 0.6);
            rimLight2.position.set(15, 8, 15);
            scene.add(rimLight2);

            // Additional point lights for casino ambiance
            const colors = [0xffd700, 0xff4757, 0x3742fa, 0x2ed573];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const pointLight = new THREE.PointLight(colors[i % colors.length], 0.5, 20);
                pointLight.position.set(
                    Math.cos(angle) * 15,
                    12 + Math.sin(i) * 3,
                    Math.sin(angle) * 15
                );
                scene.add(pointLight);
                environmentLights.push(pointLight);
            }
        }

        function createPremiumCasinoEnvironment() {
            // Enhanced floor with luxury pattern
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const floorTexture = createLuxuryFloorTexture();
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                map: floorTexture, 
                transparent: true, 
                opacity: 0.9,
                shininess: 30,
                reflectivity: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -3;
            floor.receiveShadow = true;
            scene.add(floor);

            // Premium skybox with casino atmosphere
            const skyboxGeometry = new THREE.SphereGeometry(200, 64, 64);
            const skyboxTexture = createPremiumSkyboxTexture();
            const skyboxMaterial = new THREE.MeshBasicMaterial({ 
                map: skyboxTexture, 
                side: THREE.BackSide, 
                fog: false 
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);

            // Floating casino decorations
            createCasinoDecorations();
        }

        function createCasinoDecorations() {
            // Floating poker chips in the background
            for (let i = 0; i < 20; i++) {
                const chipGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const chipMaterial = new THREE.MeshPhongMaterial({ 
                    color: Math.random() * 0xffffff,
                    shininess: 60
                });
                const chip = new THREE.Mesh(chipGeometry, chipMaterial);
                
                chip.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 20 + 10,
                    (Math.random() - 0.5) * 100
                );
                
                chip.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                scene.add(chip);
                
                // Animate floating chips
                gsap.to(chip.rotation, {
                    x: chip.rotation.x + Math.PI * 2,
                    y: chip.rotation.y + Math.PI * 2,
                    duration: 10 + Math.random() * 10,
                    repeat: -1,
                    ease: "none"
                });
                
                gsap.to(chip.position, {
                    y: chip.position.y + (Math.random() - 0.5) * 5,
                    duration: 3 + Math.random() * 4,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
        }

        function createLuxuryFloorTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 1024;

            // Create luxury marble pattern
            const gradient = ctx.createRadialGradient(512, 512, 100, 512, 512, 500);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f0f23');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 1024);

            // Add golden veins
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 1024, Math.random() * 1024);
                ctx.bezierCurveTo(
                    Math.random() * 1024, Math.random() * 1024,
                    Math.random() * 1024, Math.random() * 1024,
                    Math.random() * 1024, Math.random() * 1024
                );
                ctx.stroke();
            }

            // Add subtle pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 1024; i += 64) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 1024);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(1024, i);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createPremiumSkyboxTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2048;
            canvas.height = 1024;

            // Create casino night sky
            const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(0.3, '#1a1a2e');
            gradient.addColorStop(0.7, '#16213e');
            gradient.addColorStop(1, '#0f0f23');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2048, 1024);

            // Add casino lights effect
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 2048;
                const y = Math.random() * 400;
                const size = Math.random() * 3 + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${255}, ${Math.random() * 100 + 155}, ${Math.random() * 50}, ${Math.random() * 0.8 + 0.2})`;
                ctx.fill();
                
                // Add glow effect
                ctx.beginPath();
                ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${255}, ${Math.random() * 100 + 155}, ${Math.random() * 50}, ${Math.random() * 0.2})`;
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createLuxuryBlackjackTable() {
            tableGroup = new THREE.Group();

            // Premium table base with luxury materials
            const tableGeometry = new THREE.CylinderGeometry(7, 7, 0.6, 64);
            const woodTexture = createPremiumWoodTexture();
            const tableMaterial = new THREE.MeshPhongMaterial({ 
                map: woodTexture, 
                shininess: 60, 
                bumpMap: woodTexture,
                bumpScale: 0.03,
                reflectivity: 0.2
            });
            blackjackTable = new THREE.Mesh(tableGeometry, tableMaterial);
            blackjackTable.position.y = -0.3;
            blackjackTable.receiveShadow = true;
            blackjackTable.castShadow = true;
            tableGroup.add(blackjackTable);

            // Luxury golden edge
            const edgeGeometry = new THREE.TorusGeometry(7, 0.4, 24, 64);
            const goldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffd700, 
                shininess: 100, 
                reflectivity: 0.5,
                specular: 0xffffff
            });
            const tableEdge = new THREE.Mesh(edgeGeometry, goldMaterial);
            tableEdge.rotation.x = Math.PI / 2;
            tableEdge.position.y = 0;
            tableEdge.castShadow = true;
            tableGroup.add(tableEdge);

            // Premium felt surface
            const feltGeometry = new THREE.CylinderGeometry(6.5, 6.5, 0.1, 64);
            const feltTexture = createLuxuryFeltTexture();
            const feltMaterial = new THREE.MeshLambertMaterial({ 
                map: feltTexture, 
                bumpMap: feltTexture,
                bumpScale: 0.01,
                transparent: true,
                opacity: 0.95
            });
            const tableFelt = new THREE.Mesh(feltGeometry, feltMaterial);
            tableFelt.position.y = 0.05;
            tableFelt.receiveShadow = true;
            tableGroup.add(tableFelt);

            createPlayerPositions();
            createLuxuryTableMarkings();
            scene.add(tableGroup);
        }

        function createPremiumWoodTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;

            // Rich mahogany base
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#654321');
            gradient.addColorStop(0.3, '#8B4513');
            gradient.addColorStop(0.7, '#A0522D');
            gradient.addColorStop(1, '#8B4513');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Wood grain
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 512; i += 12) {
                ctx.beginPath();
                ctx.moveTo(0, i + Math.sin(i * 0.05) * 8);
                ctx.bezierCurveTo(
                    128, i + Math.sin(i * 0.05) * 8 + Math.random() * 4,
                    384, i + Math.sin(i * 0.05) * 8 - Math.random() * 4,
                    512, i + Math.sin(i * 0.05) * 8
                );
                ctx.stroke();
            }

            // Luxury highlights
            ctx.strokeStyle = 'rgba(205, 133, 63, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 512; i += 24) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(512, i + Math.sin(i * 0.02) * 4);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createLuxuryFeltTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;

            // Deep casino green base
            ctx.fillStyle = '#0d4d2a';
            ctx.fillRect(0, 0, 512, 512);

            // Felt texture
            const imageData = ctx.getImageData(0, 0, 512, 512);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 40;
                data[i] = Math.max(0, Math.min(255, 13 + noise));
                data[i + 1] = Math.max(0, Math.min(255, 77 + noise));
                data[i + 2] = Math.max(0, Math.min(255, 42 + noise));
            }
            ctx.putImageData(imageData, 0, 0);

            // Subtle pattern overlay
            ctx.fillStyle = 'rgba(255, 215, 0, 0.05)';
            for (let x = 0; x < 512; x += 16) {
                for (let y = 0; y < 512; y += 16) {
                    if ((x + y) % 32 === 0) {
                        ctx.fillRect(x, y, 8, 8);
                    }
                }
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createLuxuryTableMarkings() {
            // Enhanced dealer area with glow
            const dealerAreaGeometry = new THREE.RingGeometry(1.4, 1.5, 48);
            const dealerAreaMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const dealerArea = new THREE.Mesh(dealerAreaGeometry, dealerAreaMaterial);
            dealerArea.rotation.x = -Math.PI / 2;
            dealerArea.position.set(0, 0.06, -4);
            tableGroup.add(dealerArea);

            // Premium betting circles
            if (playerPositions && playerPositions.length > 0) {
                playerPositions.forEach((pos, index) => {
                    const bettingCircle = new THREE.Mesh(
                        new THREE.RingGeometry(0.45, 0.5, 32), 
                        new THREE.MeshBasicMaterial({ 
                            color: 0xffd700, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.DoubleSide
                        })
                    );
                    bettingCircle.rotation.x = -Math.PI / 2;
                    bettingCircle.position.set(pos.chipX, 0.06, pos.chipZ);
                    tableGroup.add(bettingCircle);

                    // Add glowing effect
                    const glowCircle = new THREE.Mesh(
                        new THREE.RingGeometry(0.5, 0.6, 32),
                        new THREE.MeshBasicMaterial({
                            color: 0xffd700,
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.DoubleSide
                        })
                    );
                    glowCircle.rotation.x = -Math.PI / 2;
                    glowCircle.position.set(pos.chipX, 0.07, pos.chipZ);
                    tableGroup.add(glowCircle);

                    // Animate glow
                    gsap.to(glowCircle.material, {
                        opacity: 0.1,
                        duration: 2,
                        repeat: -1,
                        yoyo: true,
                        ease: "sine.inOut"
                    });
                });
            }
        }

        function createPlayerPositions() {
            playerPositions = [];
            const radius = 5.2;
            const angleStep = Math.PI / 7;
            const startAngle = Math.PI + angleStep / 2;
            
            for (let i = 0; i < 6; i++) {
                const angle = startAngle + i * angleStep;
                playerPositions.push({
                    angle: angle,
                    x: Math.cos(angle) * radius,
                    z: Math.sin(angle) * radius,
                    cardXOffset: 0,
                    cardSpacing: 0.8,
                    chipX: Math.cos(angle) * (radius - 1.5),
                    chipZ: Math.sin(angle) * (radius - 1.5)
                });
            }
        }

        function createPremiumCardMaterials() {
            cardMaterials.back = new THREE.MeshPhongMaterial({ 
                map: createPremiumCardTexture("?", "?", true), 
                shininess: 40,
                reflectivity: 0.1
            });
        }

        function createPremiumCardTexture(rank, suitName, isBack = false) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 280;
            canvas.height = 390;
            const cornerRadius = 20;

            // Premium card background
            ctx.fillStyle = isBack ? '#1E40AF' : '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(cornerRadius, 0);
            ctx.lineTo(canvas.width - cornerRadius, 0);
            ctx.quadraticCurveTo(canvas.width, 0, canvas.width, cornerRadius);
            ctx.lineTo(canvas.width, canvas.height - cornerRadius);
            ctx.quadraticCurveTo(canvas.width, canvas.height, canvas.width - cornerRadius, canvas.height);
            ctx.lineTo(cornerRadius, canvas.height);
            ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - cornerRadius);
            ctx.lineTo(0, cornerRadius);
            ctx.quadraticCurveTo(0, 0, cornerRadius, 0);
            ctx.closePath();
            ctx.fill();

            // Card border
            ctx.strokeStyle = isBack ? '#3B82F6' : '#E5E7EB';
            ctx.lineWidth = 3;
            ctx.stroke();

            if (!isBack) {
                const suitSymbols = { 'hearts': '♥', 'diamonds': '♦', 'clubs': '♣', 'spades': '♠' };
                const suitColor = (suitName === 'hearts' || suitName === 'diamonds') ? '#DC2626' : '#111827';
                
                // Enhanced typography
                ctx.fillStyle = suitColor;
                ctx.font = 'bold 42px serif';
                ctx.textAlign = 'left';
                ctx.fillText(rank, 20, 50);
                
                ctx.font = 'bold 36px serif';
                ctx.fillText(suitSymbols[suitName] || '', 20, 90);

                // Rotated corner
                ctx.save();
                ctx.translate(canvas.width - 20, canvas.height - 50);
                ctx.rotate(Math.PI);
                ctx.font = 'bold 42px serif';
                ctx.fillText(rank, 0, 0);
                ctx.font = 'bold 36px serif';
                ctx.fillText(suitSymbols[suitName] || '', 0, 40);
                ctx.restore();

                // Center symbol
                ctx.font = 'bold 120px serif';
                ctx.textAlign = 'center';
                ctx.fillText(suitSymbols[suitName] || '', canvas.width / 2, canvas.height / 2 + 45);

                // Premium shine effect
                const shineGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                shineGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
                shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = shineGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // Premium card back design
                ctx.strokeStyle = '#FBBF24';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(cornerRadius + 5, 5);
                ctx.lineTo(canvas.width - cornerRadius - 5, 5);
                ctx.quadraticCurveTo(canvas.width - 5, 5, canvas.width - 5, cornerRadius + 5);
                ctx.lineTo(canvas.width - 5, canvas.height - cornerRadius - 5);
                ctx.quadraticCurveTo(canvas.width - 5, canvas.height - 5, canvas.width - cornerRadius - 5, canvas.height - 5);
                ctx.lineTo(cornerRadius + 5, canvas.height - 5);
                ctx.quadraticCurveTo(5, canvas.height - 5, 5, canvas.height - cornerRadius - 5);
                ctx.lineTo(5, cornerRadius + 5);
                ctx.quadraticCurveTo(5, 5, cornerRadius + 5, 5);
                ctx.closePath();
                ctx.stroke();

                // Royal pattern
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Crown design
                ctx.fillStyle = '#FBBF24';
                ctx.font = 'bold 28px serif';
                ctx.textAlign = 'center';
                ctx.fillText('♔ ROYAL ♔', centerX, centerY - 40);
                ctx.fillText('BLACKJACK', centerX, centerY);
                ctx.fillText('3D PREMIUM', centerX, centerY + 40);

                // Decorative pattern
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x1 = centerX + Math.cos(angle) * 80;
                    const y1 = centerY + Math.sin(angle) * 80;
                    const x2 = centerX + Math.cos(angle) * 100;
                    const y2 = centerY + Math.sin(angle) * 100;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createLuxuryChipMaterials() {
            const denominations = [10, 25, 50, 100, 250, 500];
            const colors = [0xFFFFFF, 0x22C55E, 0xEF4444, 0x1F2937, 0x8B5CF6, 0xF59E0B];
            
            denominations.forEach((denom, index) => {
                const chipTexture = createLuxuryChipTexture(denom, colors[index]);
                chipMaterials[denom] = new THREE.MeshPhongMaterial({ 
                    map: chipTexture, 
                    shininess: 80, 
                    reflectivity: 0.3,
                    specular: 0xffffff
                });
            });
            
            chipMaterials['default'] = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700, 
                shininess: 70,
                reflectivity: 0.2
            });
        }

        function createLuxuryChipTexture(value, baseColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            const centerX = 64;
            const centerY = 64;
            const radius = 56;

            // Premium chip base
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, `#${(baseColor + 0x444444).toString(16).padStart(6, '0')}`);
            gradient.addColorStop(0.7, `#${baseColor.toString(16).padStart(6, '0')}`);
            gradient.addColorStop(1, `#${(baseColor - 0x222222).toString(16).padStart(6, '0')}`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            // Luxury ring pattern
            for (let ring = 1; ring <= 3; ring++) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - ring * 12, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Gold accents
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 8, 0, Math.PI * 2);
            ctx.stroke();

            // Value text with luxury font
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 24px serif';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.strokeText(`$${value}`, centerX, centerY + 8);
            ctx.fillText(`$${value}`, centerX, centerY + 8);

            // Decorative elements
            ctx.fillStyle = '#FFD700';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * (radius - 20);
                const y = centerY + Math.sin(angle) * (radius - 20);
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createCard3D(cardData, position, rotationY = 0, faceUp = true) {
            const cardGroup = new THREE.Group();
            const cardWidth = 1.2, cardHeight = 1.6, cardDepth = 0.03;
            
            // Enhanced card geometry with rounded edges
            const cardGeometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);
            
            // Premium materials
            const frontTexture = faceUp ? createPremiumCardTexture(cardData.rank, cardData.suit) : createPremiumCardTexture("?", "?", true);
            const backTexture = createPremiumCardTexture("?", "?", true);
            const sideMaterial = new THREE.MeshPhongMaterial({
                color: 0xf5f5f5, 
                shininess: 20,
                reflectivity: 0.1
            });
            
            const cardMaterials = [
                sideMaterial, sideMaterial, sideMaterial, sideMaterial,
                new THREE.MeshPhongMaterial({ 
                    map: frontTexture, 
                    shininess: faceUp ? 30 : 50,
                    reflectivity: 0.1
                }),
                new THREE.MeshPhongMaterial({ 
                    map: backTexture, 
                    shininess: 50,
                    reflectivity: 0.1
                })
            ];
            
            const cardMesh = new THREE.Mesh(cardGeometry, cardMaterials);
            cardMesh.castShadow = true;
            cardMesh.receiveShadow = true;
            cardGroup.add(cardMesh);

            // Add subtle glow effect for face-up cards
            if (faceUp) {
                const glowGeometry = new THREE.PlaneGeometry(cardWidth * 1.1, cardHeight * 1.1);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.z = cardDepth / 2 + 0.001;
                cardGroup.add(glow);
            }

            cardGroup.position.copy(position);
            cardGroup.rotation.y = rotationY;
            cardGroup.userData = { 
                id: cardData.id, 
                suit: cardData.suit, 
                rank: cardData.rank, 
                faceUp: faceUp, 
                originalPosition: position.clone() 
            };
            
            return cardGroup;
        }

        function createChip3D(value, position, stackCount = 1) {
            const chipGroup = new THREE.Group();
            const chipRadius = 0.22, chipHeight = 0.08;
            
            const denomination = getChipDenomination(value);
            const chipMaterial = chipMaterials[denomination] || chipMaterials['default'];
            
            const actualStackCount = Math.min(stackCount, 12);
            
            for (let i = 0; i < actualStackCount; i++) {
                const chipGeometry = new THREE.CylinderGeometry(chipRadius, chipRadius, chipHeight, 32);
                const chip = new THREE.Mesh(chipGeometry, chipMaterial);
                
                chip.position.y = i * (chipHeight + 0.003) + chipHeight/2;
                chip.castShadow = true;
                chip.receiveShadow = true;
                chip.rotation.y = Math.random() * Math.PI * 2;
                
                chipGroup.add(chip);
                
                // Add individual chip glow
                const chipGlow = new THREE.Mesh(
                    new THREE.CylinderGeometry(chipRadius * 1.1, chipRadius * 1.1, chipHeight * 0.5, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 0.1
                    })
                );
                chipGlow.position.copy(chip.position);
                chipGroup.add(chipGlow);
            }

            chipGroup.position.copy(position);
            chipGroup.userData = { value: value, count: stackCount };
            
            // Enhanced animation
            gsap.to(chipGroup.position, {
                y: position.y + 0.08,
                duration: 2.5 + Math.random() * 2,
                yoyo: true,
                repeat: -1,
                ease: "sine.inOut"
            });
            
            // Subtle rotation
            gsap.to(chipGroup.rotation, {
                y: chipGroup.rotation.y + Math.PI * 2,
                duration: 20 + Math.random() * 10,
                repeat: -1,
                ease: "none"
            });
            
            return chipGroup;
        }

        function getChipDenomination(totalAmount) {
            if (totalAmount >= 500) return 500;
            if (totalAmount >= 250) return 250;
            if (totalAmount >= 100) return 100;
            if (totalAmount >= 50) return 50;
            if (totalAmount >= 25) return 25;
            return 10;
        }

        function createAdvancedParticleSystem() {
            const particleCount = 500;
            const particles = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 120;
                particlePositions[i3 + 1] = Math.random() * 40 + 5;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 120;

                const color = new THREE.Color();
                color.setHSL(0.15 + Math.random() * 0.1, 0.8, 0.4 + Math.random() * 0.4);
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;

                particleSizes[i] = Math.random() * 2 + 0.5;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                fog: false,
                vertexColors: true,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }

        function createFloatingParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 20;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                particle.style.width = (Math.random() * 4 + 2) + 'px';
                particle.style.height = particle.style.width;
                particlesContainer.appendChild(particle);
            }
        }

        function addEnhancedMouseControls() {
            let mouseDown = false, lastMouseX = 0, lastMouseY = 0;
            let touchStartX = 0, touchStartY = 0;
            const menuPanel = document.getElementById('menuPanel');
            const canvasEl = document.getElementById('canvas');

            canvasEl.addEventListener('mousedown', (event) => {
                if (menuPanel.classList.contains('hidden')) {
                    mouseDown = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (mouseDown && menuPanel.classList.contains('hidden') && !cameraAnimating) {
                    const deltaX = event.clientX - lastMouseX;
                    const deltaY = event.clientY - lastMouseY;
                    
                    camera.userData.targetRotationY -= deltaX * 0.003;
                    camera.userData.targetHeight = camera.userData.targetHeight || 15;
                    camera.userData.targetHeight += deltaY * 0.015;
                    camera.userData.targetHeight = Math.max(8, Math.min(25, camera.userData.targetHeight));
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                }
            });

            // Touch controls for mobile
            canvasEl.addEventListener('touchstart', (event) => {
                if (menuPanel.classList.contains('hidden') && event.touches.length === 1) {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    event.preventDefault();
                }
            });

            canvasEl.addEventListener('touchmove', (event) => {
                if (menuPanel.classList.contains('hidden') && event.touches.length === 1 && !cameraAnimating) {
                    const deltaX = event.touches[0].clientX - touchStartX;
                    const deltaY = event.touches[0].clientY - touchStartY;
                    
                    camera.userData.targetRotationY -= deltaX * 0.008;
                    camera.userData.targetHeight = camera.userData.targetHeight || 15;
                    camera.userData.targetHeight += deltaY * 0.03;
                    camera.userData.targetHeight = Math.max(8, Math.min(25, camera.userData.targetHeight));
                    
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    event.preventDefault();
                }
            });

            // Enhanced zoom with mouse wheel
            canvasEl.addEventListener('wheel', (event) => {
                if (menuPanel.classList.contains('hidden') && !cameraAnimating) {
                    event.preventDefault();
                    camera.userData.targetDistance += event.deltaY * 0.015;
                    camera.userData.targetDistance = Math.max(8, Math.min(40, camera.userData.targetDistance));
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = Date.now() * 0.001;

            // Enhanced camera movement with smooth interpolation
            if (!cameraAnimating) {
                const lerpFactor = camera.userData.smoothness || 0.05;
                const targetHeight = camera.userData.targetHeight || 15;
                const targetDistance = camera.userData.targetDistance || 20;
                
                camera.position.x = THREE.MathUtils.lerp(
                    camera.position.x, 
                    Math.sin(camera.userData.targetRotationY) * targetDistance, 
                    lerpFactor
                );
                camera.position.z = THREE.MathUtils.lerp(
                    camera.position.z, 
                    Math.cos(camera.userData.targetRotationY) * targetDistance, 
                    lerpFactor
                );
                camera.position.y = THREE.MathUtils.lerp(
                    camera.position.y, 
                    targetHeight + (targetDistance - 20) * 0.1, 
                    lerpFactor
                );
                camera.lookAt(0, 0, 0);
            }

            // Enhanced particle system animation
            if (particleSystem) {
                particleSystem.rotation.y += 0.0002;
                const positions = particleSystem.geometry.attributes.position.array;
                const sizes = particleSystem.geometry.attributes.size.array;
                
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(currentTime + i * 0.01) * 0.003;
                    if (positions[i] < 5) positions[i] = 5 + Math.random() * 30;
                    if (positions[i] > 45) positions[i] = 45 - Math.random() * 30;
                }
                
                for (let i = 0; i < sizes.length; i++) {
                    sizes[i] = 0.5 + Math.sin(currentTime * 2 + i * 0.1) * 0.3;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }

            // Animate environment lights
            environmentLights.forEach((light, index) => {
                const intensity = 0.5 + Math.sin(currentTime * 0.5 + index) * 0.2;
                light.intensity = intensity;
            });

            // Enhanced card floating animation
            const allCardObjects = [...dealerCardObjects3D, ...Object.values(playerCardObjects3D).flat()];
            allCardObjects.forEach((cardMesh, index) => {
                if (cardMesh && cardMesh.userData && cardMesh.userData.originalPosition) {
                    const baseY = cardMesh.userData.originalPosition.y;
                    cardMesh.position.y = baseY + Math.sin(currentTime * 1.2 + index * 0.3) * 0.008;
                    cardMesh.rotation.z = Math.sin(currentTime * 0.8 + index * 0.2) * 0.02;
                }
            });

            renderer.render(scene, camera);
        }

        function updateTableVisuals() {
            consoleLog("Updating premium table visuals...");
            if (!currentGameState) return;

            const cardBaseY = 0.12;
            clearDealerCards();

            // Enhanced dealer cards with premium animations
            if (currentGameState.dealer_hand && currentGameState.dealer_hand.cards) {
                currentGameState.dealer_hand.cards.forEach((cardData, index) => {
                    const position = new THREE.Vector3(-2.4 + index * 1.3, cardBaseY, -4.2);
                    const faceUp = cardData.suit !== 'back';
                    const cardObj = createCard3D(cardData, position, 0, faceUp);
                    scene.add(cardObj);
                    dealerCardObjects3D.push(cardObj);

                    // Premium entrance animation
                    gsap.fromTo(cardObj.position, 
                        { x: 0, y: cardBaseY + 3, z: 0 }, 
                        { 
                            x: position.x, 
                            y: position.y, 
                            z: position.z, 
                            duration: 0.8, 
                            ease: "back.out(1.4)", 
                            delay: index * 0.2 
                        }
                    );
                    
                    gsap.from(cardObj.rotation, { 
                        y: Math.PI * 1.5, 
                        duration: 0.8, 
                        ease: "power2.out", 
                        delay: index * 0.2 
                    });

                    // Card flip sound effect (visual feedback)
                    if (index === 0) {
                        gsap.to(cardObj.scale, {
                            x: 1.1, y: 1.1, z: 1.1,
                            duration: 0.1,
                            yoyo: true,
                            repeat: 1,
                            delay: index * 0.2
                        });
                    }
                });
            }

            // Clear previous player cards and chips
            Object.keys(playerCardObjects3D).forEach(pid => clearPlayerCards(pid));
            Object.values(chipStackObjects).forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
                gsap.killTweensOf(obj.position);
                gsap.killTweensOf(obj.rotation);
            });
            chipStackObjects = {};

            // Enhanced player cards and chips
            Object.values(currentGameState.players).forEach((player, pIndex) => {
                if (pIndex >= playerPositions.length) {
                    consoleWarn(`Player index ${pIndex} out of bounds`);
                    return;
                }

                const pos3D = playerPositions[pIndex];
                if (!playerCardObjects3D[player.id]) playerCardObjects3D[player.id] = [];

                let cardRenderIndex = 0;

                player.hands.forEach((hand, handIndex) => {
                    const handCardCount = hand.cards.length;
                    const handWidth = (handCardCount - 1) * (pos3D.cardSpacing * 0.6);
                    const handStartX = pos3D.x + pos3D.cardXOffset - handWidth / 2 + (handIndex * 2.2);

                    // Enhanced card positioning and animation
                    hand.cards.forEach((cardData, cardInHandIndex) => {
                        const cardPosition = new THREE.Vector3(
                            handStartX + cardInHandIndex * (pos3D.cardSpacing * 0.6), 
                            cardBaseY, 
                            pos3D.z
                        );
                        const cardRotationY = pos3D.angle + Math.PI / 2;
                        const cardObj = createCard3D(cardData, cardPosition, cardRotationY, true);
                        scene.add(cardObj);
                        playerCardObjects3D[player.id].push(cardObj);

                        const totalDelay = pIndex * 0.15 + cardRenderIndex * 0.1;
                        
                        // Premium card dealing animation
                        gsap.fromTo(cardObj.position, 
                            { x: 0, y: cardBaseY + 3, z: 0 }, 
                            { 
                                x: cardPosition.x, 
                                y: cardPosition.y, 
                                z: cardPosition.z, 
                                duration: 0.7, 
                                ease: "power2.out", 
                                delay: totalDelay 
                            }
                        );
                        
                        gsap.fromTo(cardObj.rotation, 
                            { y: cardRotationY + Math.PI * 1.2 }, 
                            { 
                                y: cardRotationY, 
                                duration: 0.7, 
                                ease: "power2.out", 
                                delay: totalDelay 
                            }
                        );

                        // Special effects for significant cards
                        const cardValue = getCardValue(cardData);
                        if (cardValue === 1 || cardValue === 10) { // Aces and face cards
                            gsap.to(cardObj.scale, {
                                x: 1.05, y: 1.05, z: 1.05,
                                duration: 0.2,
                                yoyo: true,
                                repeat: 1,
                                delay: totalDelay + 0.5
                            });
                        }

                        cardRenderIndex++;
                    });

                    // Enhanced betting chips
                    if (hand.bet_amount > 0) {
                        const chipPosition = new THREE.Vector3(
                            pos3D.chipX + handIndex * 0.8,
                            0.03,
                            pos3D.chipZ
                        );
                        const stackCount = Math.min(Math.ceil(hand.bet_amount / getChipDenomination(hand.bet_amount)), 10);
                        const chipStack = createChip3D(hand.bet_amount, chipPosition, stackCount);
                        scene.add(chipStack);
                        chipStackObjects[`player_bet_${player.id}_${handIndex}`] = chipStack;

                        // Premium chip entrance
                        gsap.from(chipStack.scale, {
                            x: 0, y: 0, z: 0,
                            duration: 0.5,
                            ease: "back.out(2)",
                            delay: pIndex * 0.1 + 0.3
                        });

                        // Winning chip celebration
                        if (hand.result === 'win' || hand.result === 'blackjack') {
                            gsap.to(chipStack.position, {
                                y: chipPosition.y + 0.2,
                                duration: 0.5,
                                ease: "power2.out",
                                delay: 2
                            });
                        }
                    }
                });
            });

            consoleLog("Premium table visuals updated successfully");
        }

        function getCardValue(cardData) {
            if (cardData.rank === 'A') return 1;
            if (['J', 'Q', 'K'].includes(cardData.rank)) return 10;
            return parseInt(cardData.rank);
        }

        function clearDealerCards() {
            dealerCardObjects3D.forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
                gsap.killTweensOf(obj.position);
                gsap.killTweensOf(obj.rotation);
                gsap.killTweensOf(obj.scale);
            });
            dealerCardObjects3D = [];
        }

        function clearPlayerCards(playerId) {
            if (playerCardObjects3D[playerId]) {
                playerCardObjects3D[playerId].forEach(obj => {
                    if (obj.parent) obj.parent.remove(obj);
                    gsap.killTweensOf(obj.position);
                    gsap.killTweensOf(obj.rotation);
                    gsap.killTweensOf(obj.scale);
                });
                playerCardObjects3D[playerId] = [];
            }
        }

        function clearAll3DObjects() {
            clearDealerCards();
            Object.keys(playerCardObjects3D).forEach(playerId => clearPlayerCards(playerId));
            
            Object.values(chipStackObjects).forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
                gsap.killTweensOf(obj.position);
                gsap.killTweensOf(obj.rotation);
                gsap.killTweensOf(obj.scale);
            });
            chipStackObjects = {};
        }

        // Enhanced WebSocket Connection Management
        function connectWebSocket() {
            consoleLog("Establishing premium connection...");
            if (isLoadingOrReconnecting && ws && ws.readyState === WebSocket.CONNECTING) {
                consoleLog("Connection already in progress");
                return;
            }

            isLoadingOrReconnecting = true;
            updateConnectionStatus('connecting');

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                ws.close();
            }

            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                consoleLog('Premium connection established');
                isConnected = true;
                isLoadingOrReconnecting = false;
                reconnectAttempts = 0;
                hideLoadingScreen();
                updateConnectionStatus('connected');
                showNotification('🎰 Welcome to Royal Blackjack 3D!', 'success', 4000);
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    consoleLog('Message received:', message.type);
                    handleServerMessage(message);
                } catch (e) {
                    consoleError("Error parsing server message:", e, event.data);
                    showNotification('Invalid server response', 'error');
                }
            };

            ws.onclose = function(event) {
                consoleLog(`Connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                isConnected = false;
                updateConnectionStatus('disconnected', `Code: ${event.code}`);
                
                clearAll3DObjects();
                if (!isLoadingOrReconnecting) {
                    showMainMenu();
                    animateCameraToMenu();
                }

                if (reconnectAttempts < maxReconnectAttempts && !isLoadingOrReconnecting) {
                    reconnectAttempts++;
                    const delay = Math.min(reconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000);
                    updateConnectionStatus('reconnecting');
                    showLoadingScreen(`Reconnecting to royal servers... (${reconnectAttempts}/${maxReconnectAttempts})`);
                    showNotification(`Reconnecting... Attempt ${reconnectAttempts}`, 'warning');
                    
                    setTimeout(() => {
                        if (!isConnected) {
                            connectWebSocket();
                        }
                    }, delay);
                } else if (reconnectAttempts >= maxReconnectAttempts) {
                    updateConnectionStatus('disconnected', 'Max reconnect attempts reached');
                    showNotification('Connection lost. Please refresh the page.', 'error', 10000);
                }
            };

            ws.onerror = function(error) {
                consoleError('WebSocket error:', error);
                updateConnectionStatus('disconnected', 'Connection error');
                showNotification('Connection error occurred', 'error');
            };
        }

        function sendMessage(action, payload = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = { action, payload };
                consoleLog('Sending message:', action, payload);
                try {
                    ws.send(JSON.stringify(message));
                    return true;
                } catch (e) {
                    consoleError('Error sending message:', e);
                    showNotification('Failed to send message', 'error');
                    return false;
                }
            } else {
                consoleError('WebSocket not connected:', ws ? ws.readyState : 'null');
                showNotification('Not connected to server', 'warning');
                return false;
            }
        }

        function handleServerMessage(message) {
            try {
                switch (message.type) {
                    case 'connected':
                        myPlayerId = message.data.player_id;
                        consoleLog(`Connected as player: ${myPlayerId}`);
                        hideLoadingScreen();
                        showMainMenu();
                        break;

                    case 'room_created':
                    case 'room_joined':
                        currentRoomCode = message.data.room_code;
                        isPlayerInGame = true;
                        hideLoadingScreen();
                        showGameInterface();
                        showNotification(`🏛️ Joined Royal Room: ${currentRoomCode}`, 'success');
                        animateCameraToTable();
                        break;

                    case 'spectating':
                        currentRoomCode = message.data.room_code;
                        isPlayerInGame = false;
                        hideLoadingScreen();
                        showGameInterface();
                        showNotification(`👁️ Spectating Room: ${currentRoomCode}`, 'info');
                        animateCameraToTable();
                        break;

                    case 'room_left':
                        hideLoadingScreen();
                        handleRoomLeft();
                        break;

                    case 'game_state':
                        currentGameState = message.data;
                        updateGameInterface();
                        break;

                    case 'room_list':
                        updateRoomList(message.data.rooms);
                        break;

                    case 'error':
                        consoleError('Server error:', message.message);
                        showNotification('❌ ' + message.message, 'error');
                        hideLoadingScreen();
                        break;

                    default:
                        consoleWarn('Unknown message type:', message.type);
                }
            } catch (e) {
                consoleError('Error handling server message:', e, message);
                showNotification('Error processing server response', 'error');
            }
        }

        function handleRoomLeft() {
            showMainMenu();
            showNotification('👋 Left royal room', 'info');
            animateCameraToMenu();
            currentRoomCode = null;
            currentGameState = null;
            isPlayerInGame = false;
            clearAll3DObjects();
        }

        function animateCameraToTable() {
            consoleLog("Animating camera to premium table view");
            cameraAnimating = true;
            camera.userData.targetRotationY = 0;
            camera.userData.targetDistance = 20;
            camera.userData.targetHeight = 15;

            gsap.to(camera.position, {
                duration: 2,
                x: 0,
                y: 15,
                z: 20,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 0, 0),
                onComplete: () => {
                    cameraAnimating = false;
                }
            });

            if (particleSystem) {
                gsap.to(particleSystem.material, {
                    opacity: 0.8,
                    duration: 2,
                    ease: "power2.inOut"
                });
            }
        }

        function animateCameraToMenu() {
            consoleLog("Animating camera to menu view");
            cameraAnimating = true;
            camera.userData.targetRotationY = Math.PI / 5;
            camera.userData.targetDistance = 28;
            camera.userData.targetHeight = 20;

            gsap.to(camera.position, {
                duration: 2,
                x: 12,
                y: 20,
                z: 28,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 0, 0),
                onComplete: () => {
                    cameraAnimating = false;
                }
            });

            if (particleSystem) {
                gsap.to(particleSystem.material, {
                    opacity: 0.4,
                    duration: 2,
                    ease: "power2.inOut"
                });
            }
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                gsap.to(loadingScreen, {
                    duration: 1,
                    opacity: 0,
                    scale: 0.9,
                    ease: "power2.out",
                    onComplete: () => {
                        loadingScreen.style.display = 'none';
                        consoleLog("Loading screen hidden");
                    }
                });
            }
        }

        function showLoadingScreen(text = 'Loading premium experience...') {
            const loadingScreen = document.getElementById('loadingScreen');
            const textElement = loadingScreen.querySelector('.loading-text');
            if (textElement) textElement.textContent = text;
            
            loadingScreen.style.display = 'flex';
            loadingScreen.style.opacity = '0';
            loadingScreen.style.transform = 'scale(0.9)';
            
            gsap.to(loadingScreen, {
                duration: 0.6,
                opacity: 1,
                scale: 1,
                ease: "power2.out"
            });
            
            consoleLog("Loading screen shown:", text);
        }

        function showMainMenu() {
            consoleLog("Showing main menu");
            document.getElementById('menuPanel').classList.remove('hidden');
            
            ['gameHUD', 'dealerArea', 'betControls', 'actionsPanel', 'chatPanel', 'playerHandsDisplay'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            
            clearAll3DObjects();
            
            gsap.fromTo('#menuPanel', 
                { opacity: 0, scale: 0.8, y: 50 }, 
                { opacity: 1, scale: 1, y: 0, duration: 0.8, ease: "back.out(1.4)" }
            );
        }

        function showGameInterface() {
            consoleLog("Showing premium game interface");
            document.getElementById('menuPanel').classList.add('hidden');
            
            ['gameHUD', 'dealerArea', 'chatPanel', 'playerHandsDisplay'].forEach(id => {
                document.getElementById(id).classList.remove('hidden');
            });
            
            gsap.fromTo(['#gameHUD', '#dealerArea', '#chatPanel'], 
                { opacity: 0, y: -30 }, 
                { opacity: 1, y: 0, duration: 0.6, ease: "power2.out", stagger: 0.1 }
            );
        }

        function updateGameInterface() {
            if (!currentGameState) return;

            consoleLog("Updating game interface: Phase:", currentGameState.phase, "Owner:", currentGameState.owner_id, "MyID:", myPlayerId);

            // Update UI elements
            document.getElementById('currentRoomCodeDisplay').textContent = currentGameState.room_code || '-';
            document.getElementById('phaseText').textContent = currentGameState.phase.replace(/_/g, ' ').toUpperCase();
            document.getElementById('handNumber').textContent = currentGameState.hand_number || '0';

            const myPlayerState = currentGameState.players[myPlayerId];
            if (myPlayerState) {
                document.getElementById('moneyAmount').textContent = myPlayerState.money.toLocaleString();
            } else {
                document.getElementById('moneyAmount').textContent = 'N/A (Spectator)';
            }

            // Show appropriate controls based on game state
            if (currentGameState.phase === 'waiting' && myPlayerState && isPlayerInGame && myPlayerState.hands[0]?.bet_amount === 0) {
                showElement('betControls');
                hideElement('actionsPanel');
            } else if (currentGameState.can_act && currentGameState.available_actions && isPlayerInGame) {
                hideElement('betControls');
                showElement('actionsPanel');
                updateActionButtons();
            } else {
                hideElement('betControls');
                hideElement('actionsPanel');
            }

            updateDealerDisplay();
            updatePlayerHandsUI();
            updateChat();
            updateTableVisuals();

            // Enhanced start button logic
            const startBtn = document.getElementById('startGameBtn');
            const canStartGame = currentGameState.phase === 'waiting' &&
                                 myPlayerState &&
                                 myPlayerState.id === currentGameState.owner_id &&
                                 Object.values(currentGameState.players).some(p => p.hands[0]?.bet_amount > 0);

            if (canStartGame) {
                startBtn.style.display = 'block';
                gsap.fromTo(startBtn, 
                    { scale: 0.8, boxShadow: '0 8px 16px rgba(255, 215, 0, 0.3)' }, 
                    { scale: 1, boxShadow: '0 12px 24px rgba(255, 215, 0, 0.6)', duration: 0.4, ease: "back.out(1.7)" }
                );
            } else {
                startBtn.style.display = 'none';
            }
        }

        function showElement(elementId) {
            const element = document.getElementById(elementId);
            if (element && element.classList.contains('hidden')) {
                element.classList.remove('hidden');
                gsap.fromTo(element, 
                    { opacity: 0, y: 30 }, 
                    { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
                );
            }
        }

        function hideElement(elementId) {
            const element = document.getElementById(elementId);
            if (element && !element.classList.contains('hidden')) {
                gsap.to(element, {
                    opacity: 0,
                    y: -30,
                    duration: 0.4,
                    ease: "power2.in",
                    onComplete: () => element.classList.add('hidden')
                });
            }
        }

        function updateDealerDisplay() {
            const dealerHandEl = document.getElementById('dealerHand');
            const dealerValueEl = document.getElementById('dealerValue');
            
            if (!currentGameState.dealer_hand || !currentGameState.dealer_hand.cards) {
                dealerHandEl.innerHTML = '';
                dealerValueEl.textContent = 'No cards';
                return;
            }

            dealerHandEl.innerHTML = '';

            currentGameState.dealer_hand.cards.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card-mini';
                
                if (card.suit === 'back') {
                    cardDiv.classList.add('back');
                    cardDiv.textContent = '?';
                } else {
                    if (card.suit === 'hearts' || card.suit === 'diamonds') {
                        cardDiv.classList.add('red');
                    }
                    cardDiv.textContent = card.rank;
                }
                
                dealerHandEl.appendChild(cardDiv);
                
                // Enhanced card entrance animation
                gsap.fromTo(cardDiv, 
                    { opacity: 0, scale: 0, rotationY: 180 }, 
                    { opacity: 1, scale: 1, rotationY: 0, duration: 0.6, delay: index * 0.15, ease: "back.out(1.7)" }
                );
            });

            if (currentGameState.dealer_hand.value !== null && currentGameState.dealer_hand.value !== undefined) {
                const newValue = `Value: ${currentGameState.dealer_hand.value}`;
                if (dealerValueEl.textContent !== newValue) {
                    gsap.fromTo(dealerValueEl, 
                        { scale: 1.3, color: '#ffd700' }, 
                        { scale: 1, color: '#ffffff', duration: 0.6, ease: "power2.out", overwrite: "auto" }
                    );
                }
                dealerValueEl.textContent = newValue;
            } else {
                dealerValueEl.textContent = 'Hidden';
            }
        }

        function updateActionButtons() {
            if (!currentGameState.available_actions) return;

            const actions = currentGameState.available_actions;
            const buttonIds = ['hitBtn', 'standBtn', 'doubleBtn', 'splitBtn', 'surrenderBtn'];

            // Hide all buttons first
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
            });

            // Show and enable available actions with premium animations
            actions.forEach((actionData, index) => {
                const btnId = actionData.action + 'Btn';
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.style.display = 'inline-block';
                    btn.disabled = false;
                    
                    gsap.fromTo(btn, 
                        { opacity: 0, scale: 0.8, y: 30 }, 
                        { 
                            opacity: 1, 
                            scale: 1, 
                            y: 0, 
                            duration: 0.5, 
                            delay: index * 0.1, 
                            ease: "back.out(1.7)", 
                            overwrite: "auto" 
                        }
                    );
                }
            });
        }

        function updatePlayerHandsUI() {
            const container = document.getElementById('playerHandsDisplay');
            container.innerHTML = '';
            
            if (!currentGameState.players) return;

            Object.values(currentGameState.players).forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-hand';
                
                // Enhanced status classes
                if (player.is_current_player) playerDiv.classList.add('current-player');
                if (player.status === 'bust') playerDiv.classList.add('bust');
                if (player.status === 'blackjack') playerDiv.classList.add('blackjack');
                if (player.id === myPlayerId) {
                    playerDiv.style.borderColor = '#00ffff';
                    playerDiv.style.boxShadow = '0 0 30px rgba(0, 255, 255, 0.5)';
                }

                let handsHtml = '';
                player.hands.forEach((hand, handIndex) => {
                    const cardsHtml = hand.cards.map(card => 
                        `<div class="${(card.suit === 'hearts' || card.suit === 'diamonds') ? 'card-mini red' : card.suit === 'back' ? 'card-mini back' : 'card-mini'}">${card.suit === 'back' ? '?' : card.rank}</div>`
                    ).join('');
                    
                    handsHtml += `
                        <div class="hand-info" style="border-top: ${handIndex > 0 ? '1px solid rgba(255,215,0,0.3)' : 'none'}; margin-top: ${handIndex > 0 ? '12px' : '0'}; padding-top: ${handIndex > 0 ? '12px' : '0'};">
                            <div class="hand-cards">${cardsHtml}</div>
                            <div><strong>Value:</strong> ${hand.value !== undefined ? hand.value : 'N/A'}</div>
                            <div><strong>Bet:</strong> ${hand.bet_amount}</div>
                            ${hand.result ? `<div style="color: ${getResultColor(hand.result)}; font-weight: bold; text-transform: uppercase;">${hand.result}</div>` : ''}
                            ${hand.payout > 0 && hand.result !== 'push' ? `<div style="color: #00ffaa; font-weight: bold;">Won: ${hand.payout - hand.bet_amount}</div>` : ''}
                            ${hand.payout > 0 && hand.result === 'push' ? `<div style="color: #ffaa00; font-weight: bold;">Push: ${hand.bet_amount} returned</div>` : ''}
                        </div>
                    `;
                });

                playerDiv.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-money">💰 ${player.money.toLocaleString()}</div>
                    ${handsHtml}
                `;

                container.appendChild(playerDiv);
                
                // Premium entrance animation
                gsap.fromTo(playerDiv, 
                    { opacity: 0, scale: 0.9, y: 20 }, 
                    { opacity: 1, scale: 1, y: 0, duration: 0.5, delay: index * 0.08, ease: "power2.out", overwrite: "auto" }
                );
            });
        }

        function getResultColor(result) {
            switch(result) {
                case 'win':
                case 'blackjack':
                    return '#00ff88';
                case 'lose':
                case 'bust':
                    return '#ff4757';
                case 'push':
                    return '#ffa502';
                default:
                    return '#ffffff';
            }
        }

        function updateChat() {
            if (!currentGameState || !currentGameState.chat_messages) return;

            const chatMessagesEl = document.getElementById('chatMessages');
            const shouldScroll = chatMessagesEl.scrollHeight - chatMessagesEl.clientHeight <= chatMessagesEl.scrollTop + 30;
            
            const currentMessageCount = chatMessagesEl.children.length;
            const newMessages = currentGameState.chat_messages;

            if (currentMessageCount !== newMessages.length || 
                (newMessages.length > 0 && chatMessagesEl.lastChild?.textContent !== newMessages[newMessages.length-1].message)) {
                
                chatMessagesEl.innerHTML = '';
                
                newMessages.forEach((msg, index) => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'chat-message';
                    msgDiv.style.borderLeftColor = msg.player_color || '#ffd700';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'chat-player-name';
                    nameSpan.style.color = msg.player_color || '#ffd700';
                    nameSpan.textContent = msg.player_name + ': ';
                    
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = msg.message;
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-timestamp';
                    timeSpan.textContent = msg.formatted_time;
                    
                    msgDiv.appendChild(nameSpan);
                    msgDiv.appendChild(messageSpan);
                    msgDiv.appendChild(timeSpan);
                    chatMessagesEl.appendChild(msgDiv);
                    
                    // Enhanced message animation
                    gsap.fromTo(msgDiv, 
                        { opacity: 0, x: 30, scale: 0.9 }, 
                        { opacity: 1, x: 0, scale: 1, duration: 0.4, ease: "power2.out", delay: index * 0.03, overwrite: "auto" }
                    );
                });
                
                if (shouldScroll || !chatCollapsed) {
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                }
            }
        }

        // Game Action Functions
        function createQuickRoom() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                return;
            }
            if (sendMessage('create_room', { player_name: name })) {
                showLoadingScreen('Creating your royal room...');
            }
        }

        function createCustomRoom() {
            const name = document.getElementById('playerName').value.trim();
            const roomName = document.getElementById('roomName').value.trim();
            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                return;
            }
            if (sendMessage('create_room', { player_name: name, room_name: roomName || null })) {
                showLoadingScreen('Creating your custom royal room...');
            }
        }

        function joinRoomFromInput() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            const name = document.getElementById('playerName').value.trim();
            if (!code) {
                showNotification("🏛️ Please enter room code", "warning");
                return;
            }
            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                return;
            }
            if (sendMessage('join_room', { room_code: code, player_name: name })) {
                showLoadingScreen('Joining royal room...');
            }
        }

        function spectateRoomFromInput() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!code) {
                showNotification("🏛️ Please enter room code", "warning");
                return;
            }
            if (sendMessage('spectate_room', { room_code: code })) {
                showLoadingScreen('Joining as royal spectator...');
            }
        }

        function leaveRoom() {
            if (confirm("Are you sure you want to leave this royal room?")) {
                if (sendMessage('leave_room')) {
                    showLoadingScreen('Leaving royal room...');
                }
            }
        }

        function startGame() {
            if (sendMessage('start_game')) {
                showNotification('🚀 Starting royal game...', 'info');
            }
        }

        // Betting Functions
        const MIN_BET_DYNAMIC = () => currentGameState?.min_bet || 10;
        const MAX_BET_DYNAMIC = () => currentGameState?.max_bet || 500;

        function setBetAmount(amount) {
            const input = document.getElementById('betAmountInput');
            input.value = amount;
            
            gsap.fromTo(input, 
                { scale: 1.1, borderColor: '#ffd700', boxShadow: '0 0 20px rgba(255, 215, 0, 0.6)' }, 
                { scale: 1, borderColor: 'var(--royal-gold)', boxShadow: '0 0 15px rgba(255, 215, 0, 0.3)', duration: 0.4, ease: "power2.out", overwrite: "auto" }
            );
        }

        function placeBet() {
            const amount = parseInt(document.getElementById('betAmountInput').value);
            if (isNaN(amount) || amount < MIN_BET_DYNAMIC() || amount > MAX_BET_DYNAMIC()) {
                showNotification(`💰 Bet must be ${MIN_BET_DYNAMIC()}-${MAX_BET_DYNAMIC()}`, "warning");
                return;
            }

            const myPlayerState = currentGameState.players[myPlayerId];
            if (myPlayerState && amount > myPlayerState.money) {
                showNotification("💸 Insufficient royal funds", "error");
                return;
            }

            if (sendMessage('player_action', { action_type: 'place_bet', amount: amount })) {
                showNotification(`💎 Royal bet placed: ${amount}`, 'success');
                hideElement('betControls');
            }
        }

        function playerAction(actionType) {
            if (sendMessage('player_action', { action_type: actionType })) {
                const actionNames = {
                    'hit': '👆 HIT',
                    'stand': '✋ STAND',
                    'double_down': '⚡ DOUBLE DOWN',
                    'split': '✂️ SPLIT',
                    'surrender': '🏳️ SURRENDER'
                };
                showNotification(`🎯 ${actionNames[actionType] || actionType.toUpperCase()}`, 'info');
            }
        }

        // Chat Functions
        function sendChat() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            if (message.length > 200) {
                showNotification("💬 Message too long", "warning");
                return;
            }
            
            if (sendMessage('send_chat_message', { message: message })) {
                input.value = '';
                gsap.fromTo(input, 
                    { backgroundColor: 'rgba(0, 255, 0, 0.2)' }, 
                    { backgroundColor: 'var(--glass-bg)', duration: 0.6, overwrite: "auto" }
                );
            }
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                sendChat();
            }
        }

        function toggleChat() {
            chatCollapsed = !chatCollapsed;
            const chatPanel = document.getElementById('chatPanel');
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.querySelector('.chat-input-container');
            const chatToggle = document.getElementById('chatToggle');
            
            const originalHeight = chatPanel.dataset.originalHeight || '300px';
            if (!chatPanel.dataset.originalHeight) {
                chatPanel.dataset.originalHeight = chatPanel.offsetHeight + 'px';
            }

            if (chatCollapsed) {
                gsap.to([chatMessages, chatInput], {
                    height: 0,
                    opacity: 0,
                    duration: 0.4,
                    onComplete: () => {
                        chatMessages.style.display = 'none';
                        chatInput.style.display = 'none';
                    }
                });
                gsap.to(chatPanel, { height: '60px', duration: 0.4 });
                chatToggle.textContent = '+';
            } else {
                chatMessages.style.display = 'block';
                chatInput.style.display = 'flex';
                gsap.set(chatMessages, { height: 'auto' });
                const targetHeight = chatMessages.offsetHeight;
                gsap.set(chatMessages, { height: 0 });
                
                gsap.to(chatPanel, { height: originalHeight, duration: 0.4 });
                gsap.to(chatMessages, { height: targetHeight, opacity: 1, duration: 0.4 });
                gsap.to(chatInput, { height: 'auto', opacity: 1, duration: 0.4 });
                chatToggle.textContent = '−';
                
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 100);
            }
        }

        // Room List Functions
        function showRoomList() {
            document.getElementById('roomListModal').classList.remove('hidden');
            gsap.fromTo('#roomListModal', 
                { opacity: 0, scale: 0.9 }, 
                { opacity: 1, scale: 1, duration: 0.4 }
            );
            refreshRoomList();
        }

        function hideRoomList() {
            gsap.to('#roomListModal', {
                opacity: 0,
                scale: 0.9,
                duration: 0.4,
                onComplete: () => document.getElementById('roomListModal').classList.add('hidden')
            });
        }

        function refreshRoomList() {
            sendMessage('get_room_list');
            document.getElementById('roomList').innerHTML = `
                <div style="text-align: center; color: #ccc; padding: 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 25px; width: 80px; height: 80px;"></div>
                    Fetching royal rooms...
                </div>
            `;
        }

        function updateRoomList(rooms) {
            const listElement = document.getElementById('roomList');
            
            if (!rooms || rooms.length === 0) {
                listElement.innerHTML = `
                    <div style="text-align: center; color: #ccc; padding: 40px;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">🏛️</div>
                        <div style="font-size: 1.2rem;">No public royal rooms available</div>
                        <div style="font-size: 0.9rem; margin-top: 10px; opacity: 0.7;">Create your own room to start playing!</div>
                    </div>
                `;
                return;
            }

            listElement.innerHTML = rooms.map((room, index) => `
                <div style="background: var(--glass-bg); border-radius: 15px; padding: 20px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; opacity: 0; border: 1px solid rgba(255, 215, 0, 0.3); transition: all 0.3s ease;" id="room-${index}" onmouseover="this.style.borderColor='var(--royal-gold)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.borderColor='rgba(255, 215, 0, 0.3)'; this.style.transform='translateY(0)'">
                    <div>
                        <strong style="color: var(--royal-gold); font-size: 1.1rem;">${room.name || room.code}</strong>
                        <br>
                        <small style="color: #ccc; font-size: 0.9rem;">
                            👥 Players: ${room.players}/${room.max_players} | 
                            🎮 Phase: ${room.phase.replace('_', ' ').toUpperCase()} |
                            🕐 Created: ${room.created}
                        </small>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="premium-button" onclick="joinRoomByCode('${room.code}')" style="min-width: 80px;">Join</button>
                        <button class="premium-button" onclick="spectateRoomByCode('${room.code}')" style="min-width: 80px;">Spectate</button>
                    </div>
                </div>
            `).join('');

            // Animate room entries
            rooms.forEach((_, index) => {
                gsap.fromTo(`#room-${index}`, 
                    { opacity: 0, x: -50, scale: 0.95 }, 
                    { opacity: 1, x: 0, scale: 1, duration: 0.5, delay: index * 0.1, ease: "power2.out", overwrite: "auto" }
                );
            });
        }

        function joinRoomByCode(code) {
            const name = document.getElementById('playerName').value.trim() || 'Royal Player';
            hideRoomList();
            if (sendMessage('join_room', { room_code: code, player_name: name })) {
                showLoadingScreen('Joining royal room...');
            }
        }

        function spectateRoomByCode(code) {
            hideRoomList();
            if (sendMessage('spectate_room', { room_code: code })) {
                showLoadingScreen('Joining as royal spectator...');
            }
        }

        // Enhanced Notification System
        function showNotification(message, type = 'info', duration = 5000) {
            const container = document.getElementById('notificationContainer');
            if (!container) return;

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            container.appendChild(notification);

            // Enhanced entrance animation
            gsap.fromTo(notification, 
                { y: -100, opacity: 0, scale: 0.8, rotationX: -90 }, 
                { y: 0, opacity: 1, scale: 1, rotationX: 0, duration: 0.6, ease: "back.out(1.7)" }
            );

            // Auto-remove with enhanced exit animation
            setTimeout(() => {
                gsap.to(notification, {
                    y: -100,
                    opacity: 0,
                    scale: 0.8,
                    rotationX: 90,
                    duration: 0.5,
                    ease: "power2.in",
                    onComplete: () => notification.remove()
                });
            }, duration);
        }

        // Enhanced Event Listeners
        window.addEventListener('resize', function() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                consoleLog("Window resized - updated renderer");
            }
        });

        document.addEventListener('keydown', function(event) {
            if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
            if (!currentGameState || !currentGameState.can_act || !currentGameState.available_actions) return;

            const actions = currentGameState.available_actions.map(a => a.action);
            const keyActions = {
                'h': 'hit',
                's': 'stand', 
                'd': 'double_down',
                'p': 'split',
                'r': 'surrender'
            };

            const action = keyActions[event.key.toLowerCase()];
            if (action && actions.includes(action)) {
                playerAction(action);
            }
        });

        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                consoleLog("Page hidden - reducing activity");
            } else {
                consoleLog("Page visible - resuming activity");
                if (!isConnected && !isLoadingOrReconnecting) {
                    consoleLog("Reconnecting on page visibility");
                    connectWebSocket();
                }
            }
        });

        window.addEventListener('error', function(event) {
            consoleError('Global error:', event.message, 'at', event.filename, ':', event.lineno);
            showNotification('⚠️ An error occurred. Please refresh if issues persist.', 'error', 8000);
        });

        window.addEventListener('unhandledrejection', function(event) {
            consoleError('Unhandled promise rejection:', event.reason);
            showNotification('⚠️ Unexpected error occurred.', 'error', 6000);
        });

        // Enhanced Application Initialization
        window.addEventListener('load', function() {
            consoleLog("🎰 Royal Blackjack 3D initializing...");
            const loadingTextEl = document.getElementById('loadingScreen').querySelector('.loading-text');
            
            if (!loadingTextEl) {
                consoleError("Loading text element not found");
                alert("Initialization error - please refresh the page.");
                return;
            }

            try {
                loadingTextEl.textContent = "Loading premium libraries...";
                
                // Verify required libraries
                if (typeof THREE === 'undefined') throw new Error("Three.js library missing");
                if (typeof gsap === 'undefined') throw new Error("GSAP library missing");

                loadingTextEl.textContent = "Initializing 3D engine...";
                if (!initThreeJS()) throw new Error("3D engine initialization failed");

                loadingTextEl.textContent = "Connecting to royal servers...";
                connectWebSocket();
                
                consoleLog("🎰 Royal Blackjack 3D initialization sequence started successfully");
            } catch (e) {
                consoleError("Initialization error:", e);
                loadingTextEl.textContent = "Error: " + e.message;
                
                if (typeof showNotification === "function") {
                    showNotification("⚠️ Initialization failed: " + e.message, "error", 15000);
                } else {
                    alert("Initialization failed: " + e.message);
                }
                
                updateConnectionStatus('disconnected', e.message);
            }
        });

        window.addEventListener('beforeunload', function() {
            consoleLog("🎰 Royal Blackjack 3D shutting down...");
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, "Page unload");
            }
        });

        // Add some royal flair with periodic effects
        setInterval(() => {
            if (Math.random() < 0.1) { // 10% chance every interval
                // Create a subtle golden sparkle effect
                const sparkle = document.createElement('div');
                sparkle.style.position = 'fixed';
                sparkle.style.left = Math.random() * 100 + '%';
                sparkle.style.top = Math.random() * 100 + '%';
                sparkle.style.width = '4px';
                sparkle.style.height = '4px';
                sparkle.style.background = 'radial-gradient(circle, #ffd700, transparent)';
                sparkle.style.borderRadius = '50%';
                sparkle.style.pointerEvents = 'none';
                sparkle.style.zIndex = '1';
                document.body.appendChild(sparkle);
                
                gsap.to(sparkle, {
                    opacity: 0,
                    scale: 3,
                    duration: 2,
                    ease: "power2.out",
                    onComplete: () => sparkle.remove()
                });
            }
        }, 2000);

        consoleLog("🎰 Royal Blackjack 3D script loaded and ready for initialization");
    </script>
</body>
</html>
