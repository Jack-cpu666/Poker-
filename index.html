<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎰 Royal Blackjack 3D - Premium Casino Experience</title>
    <!-- Fixed CDN URLs with fallbacks -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js" onerror="loadThreeJSFallback()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Fallback Three.js -->
    <script>
        function loadThreeJSFallback() {
            console.warn('Primary Three.js CDN failed, loading fallback...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
            script.onerror = function() {
                console.error('All Three.js CDNs failed, using 2D mode');
                window.THREEJS_FAILED = true;
            };
            document.head.appendChild(script);
        }

        // WebGL Detection
        function detectWebGL() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }

        window.WEBGL_SUPPORTED = detectWebGL();
        if (!window.WEBGL_SUPPORTED) {
            console.warn('WebGL not supported, will use 2D fallback mode');
        }
    </script>

    <style>
        :root {
            --royal-gold: #FFD700;
            --royal-gold-dark: #B8860B;
            --casino-red: #DC143C;
            --casino-green: #228B22;
            --deep-blue: #000080;
            --platinum: #E5E4E2;
            --dark-bg: #0a0a0a;
            --panel-bg: rgba(0, 0, 0, 0.9);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --shadow-gold: rgba(255, 215, 0, 0.5);
            --text-gold: #FFD700;
            --text-white: #FFFFFF;
            --text-dark: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: var(--text-white);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background:
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 215, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(220, 20, 60, 0.2) 0%, transparent 50%);
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #canvas {
            display: block;
            cursor: grab;
            flex: 1;
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.3));
        }

        #canvas:active { cursor: grabbing; }

        /* 2D Fallback Mode */
        .fallback-2d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at center, #2a2a4e 0%, #1a1a3e 50%, #0f0f23 100%),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="%23333" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }

        .fallback-table {
            width: 600px;
            height: 400px;
            background: linear-gradient(135deg, #0d4d2a, #1a5d3a);
            border-radius: 50%;
            border: 8px solid var(--royal-gold);
            position: relative;
            box-shadow:
                0 0 50px rgba(255, 215, 0, 0.3),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .fallback-table::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 60%;
            background: radial-gradient(ellipse, rgba(255, 215, 0, 0.1) 0%, transparent 70%);
            border-radius: 50%;
        }

        /* Premium Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: all 1s ease-out;
        }

        .logo-container {
            position: relative;
            margin-bottom: 40px;
        }

        .loading-logo {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            animation: logoGlow 3s ease-in-out infinite;
            text-align: center;
            position: relative;
        }

        .loading-logo::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: logoHalo 4s linear infinite;
            z-index: -1;
        }

        @keyframes logoGlow {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.05); filter: brightness(1.2); }
        }

        @keyframes logoHalo {
            0% { transform: rotate(0deg) scale(1); opacity: 0.3; }
            50% { transform: rotate(180deg) scale(1.1); opacity: 0.6; }
            100% { transform: rotate(360deg) scale(1); opacity: 0.3; }
        }

        .loading-spinner {
            width: 100px;
            height: 100px;
            border: 6px solid rgba(255, 215, 0, 0.2);
            border-top: 6px solid var(--royal-gold);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
            position: relative;
        }

        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 4px solid transparent;
            border-top: 4px solid rgba(255, 215, 0, 0.6);
            border-radius: 50%;
            animation: spin 1s linear infinite reverse;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.4rem;
            color: var(--text-white);
            opacity: 0.9;
            text-align: center;
            font-weight: 300;
            letter-spacing: 2px;
            animation: textPulse 2s ease-in-out infinite;
        }

        @keyframes textPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Premium UI Overlay System */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            position: absolute;
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border-radius: 20px;
            padding: 25px;
            color: var(--text-white);
            pointer-events: auto;
            border: 2px solid var(--royal-gold);
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 30px rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(20px);
            transition: all 0.4s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        .ui-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--royal-gold), transparent, var(--royal-gold));
            border-radius: 20px;
            z-index: -1;
            opacity: 0.7;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Enhanced Menu Panel */
        .menu-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            min-width: 500px;
            max-width: 90vw;
            z-index: 9000;
        }

        .menu-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            animation: titleShine 3s ease-in-out infinite;
            text-align: center;
            position: relative;
        }

        .menu-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--royal-gold), transparent);
            animation: underlineGlow 2s ease-in-out infinite;
        }

        @keyframes titleShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes underlineGlow {
            0%, 100% { opacity: 0.5; transform: translateX(-50%) scaleX(1); }
            50% { opacity: 1; transform: translateX(-50%) scaleX(1.2); }
        }

        .menu-section {
            margin-bottom: 25px;
            padding: 20px;
            background: var(--glass-bg);
            border-radius: 15px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .menu-section:hover {
            border-color: var(--royal-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }

        .menu-section h3 {
            color: var(--royal-gold);
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
            text-align: center;
            position: relative;
        }

        .menu-section h3::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 1px;
            background: var(--royal-gold);
        }

        /* Premium Button Styles */
        .premium-button {
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark));
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            color: var(--text-dark);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow:
                0 8px 16px rgba(255, 215, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            min-width: 140px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Montserrat', sans-serif;
            user-select: none;
        }

        .premium-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .premium-button:hover::before {
            left: 100%;
        }

        .premium-button:hover {
            transform: translateY(-3px);
            box-shadow:
                0 12px 24px rgba(255, 215, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .premium-button:active {
            transform: translateY(-1px);
        }

        .premium-button:disabled {
            background: linear-gradient(45deg, #666, #888);
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
            box-shadow: none;
        }

        /* Specialized Button Colors */
        .button-hit {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .button-stand {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .button-double {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .button-split {
            background: linear-gradient(45deg, #6f42c1, #5a32a3);
            color: white;
        }

        .button-surrender {
            background: linear-gradient(45deg, #fd7e14, #e66100);
            color: white;
        }

        /* Enhanced Game HUD */
        .game-hud {
            top: 30px;
            left: 30px;
            max-width: 380px;
            z-index: 800;
            max-height: 50vh;
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px 16px;
            background: var(--glass-bg);
            border-radius: 10px;
            border-left: 4px solid var(--royal-gold);
            transition: all 0.3s ease;
        }

        .hud-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .hud-label {
            font-weight: 500;
            color: var(--royal-gold);
            font-size: 0.95rem;
        }

        .hud-value {
            font-weight: 700;
            color: var(--text-white);
            font-size: 1rem;
            font-family: 'Cinzel', serif;
        }

        /* Enhanced Dealer Area */
        .dealer-area {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            min-width: 350px;
            backdrop-filter: blur(20px);
            z-index: 700;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .dealer-title {
            font-family: 'Cinzel', serif;
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--royal-gold);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dealer-hand {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .dealer-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-white);
            font-family: 'Cinzel', serif;
        }

        /* Enhanced Action Panels */
        .actions-panel {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 600;
        }

        /* Enhanced Betting Controls Positioning */
        .bet-panel-custom-location {
            bottom: 200px; /* Adjust this value for precise vertical alignment */
                           /* Player hands are at bottom: 180px */
            left: 30px;
            max-width: 380px; /* Similar to Game HUD or Chat Panel width */
            z-index: 600;     /* Ensures it's above player hands (400) and chat (500) */
        }

        /* Enhanced Betting Controls */
        .bet-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            /* background: var(--glass-bg); */ /* REMOVED */
            /* padding: 20px; */             /* REMOVED */
            /* border-radius: 15px; */       /* REMOVED */
            /* margin-bottom: 20px; */       /* REMOVED */
            flex-wrap: wrap;
            justify-content: center;
            /* border: 1px solid rgba(255, 215, 0, 0.3); */ /* REMOVED */
            width: 100%; /* ADDED */
        }


        .bet-label {
            color: var(--royal-gold);
            font-weight: 600;
            font-size: 1.1rem;
            white-space: nowrap;
        }

        .bet-input {
            padding: 12px;
            border: 2px solid var(--royal-gold);
            border-radius: 10px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 1.1rem;
            text-align: center;
            width: 120px;
            min-width: 100px;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            outline: none;
            transition: all 0.3s ease;
        }

        .bet-input:focus {
            border-color: var(--royal-gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
        }

        .bet-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .bet-button {
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark));
            color: var(--text-dark);
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            user-select: none;
        }

        .bet-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }

        /* Enhanced Chat Panel */
        .chat-panel {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 350px;
            max-height: 60vh;
            min-height: 300px;
            background: linear-gradient(135deg, var(--panel-bg), rgba(26, 26, 46, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
            z-index: 500;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--royal-gold);
            flex-shrink: 0;
        }

        .chat-title {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            color: var(--royal-gold);
            font-size: 1.2rem;
        }

        .chat-toggle {
            background: none;
            border: 2px solid var(--royal-gold);
            color: var(--royal-gold);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            user-select: none;
        }

        .chat-toggle:hover {
            background: var(--royal-gold);
            color: var(--text-dark);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            background: var(--glass-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            min-height: 180px;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-left: 3px solid var(--royal-gold);
            animation: slideInChat 0.4s ease-out;
            word-wrap: break-word;
            font-size: 0.9rem;
        }

        @keyframes slideInChat {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chat-player-name {
            font-weight: 700;
            margin-right: 8px;
        }

        .chat-timestamp {
            font-size: 0.8rem;
            opacity: 0.7;
            float: right;
        }

        .chat-input-container {
            display: flex;
            gap: 12px;
            margin-top: auto;
            flex-shrink: 0;
        }

        .chat-input-container input {
            flex: 1;
            padding: 12px;
            border: 2px solid var(--royal-gold);
            border-radius: 10px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 0.9rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .chat-input-container input:focus {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }

        /* Enhanced Player Hands Display */
        .player-hands {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 400;
        }

        .player-hand {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(10, 10, 30, 0.95));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            min-width: 220px;
            position: relative;
            transition: all 0.4s ease;
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
        }

        .player-hand.current-player {
            border-color: #ff4757;
            box-shadow:
                0 0 40px rgba(255, 71, 87, 0.6),
                0 15px 30px rgba(0, 0, 0, 0.4);
            animation: currentPlayerPulse 2s ease-in-out infinite;
        }

        @keyframes currentPlayerPulse {
            0%, 100% {
                box-shadow:
                    0 0 40px rgba(255, 71, 87, 0.6),
                    0 15px 30px rgba(0, 0, 0, 0.4);
            }
            50% {
                box-shadow:
                    0 0 60px rgba(255, 71, 87, 0.9),
                    0 20px 40px rgba(0, 0, 0, 0.5);
            }
        }

        .player-hand.blackjack {
            border-color: var(--royal-gold);
            animation: blackjackGlow 1.5s ease-in-out infinite;
        }

        @keyframes blackjackGlow {
            0%, 100% {
                box-shadow:
                    0 0 30px rgba(255, 215, 0, 0.5),
                    0 15px 30px rgba(0, 0, 0, 0.4);
            }
            50% {
                box-shadow:
                    0 0 50px rgba(255, 215, 0, 0.8),
                    0 20px 40px rgba(0, 0, 0, 0.5);
            }
        }

        .player-hand.bust {
            opacity: 0.5;
            filter: grayscale(70%);
            border-color: #666;
        }

        .player-name {
            font-weight: 700;
            color: var(--text-white);
            margin-bottom: 12px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
        }

        .player-money {
            color: var(--royal-gold);
            font-weight: 700;
            font-family: 'Cinzel', serif;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .hand-info {
            margin: 8px 0;
            font-size: 0.95rem;
        }

        .hand-cards {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .card-mini {
            width: 35px;
            height: 48px;
            background: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: black;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: transform 0.2s ease;
        }

        .card-mini:hover {
            transform: translateY(-2px);
        }

        .card-mini.red { color: #dc3545; }
        .card-mini.back {
            background: linear-gradient(135deg, #1e3a8a, #3b82f6);
            color: white;
        }

        /* Enhanced Form Elements */
        input, select {
            padding: 15px 20px;
            border: 2px solid var(--royal-gold);
            border-radius: 12px;
            background: var(--glass-bg);
            color: var(--text-white);
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: 'Montserrat', sans-serif;
            outline: none;
            user-select: text;
        }

        input:focus, select:focus {
            border-color: var(--royal-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Enhanced Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, var(--royal-gold), var(--royal-gold-dark));
            border-radius: 5px;
            transition: background 0.3s ease;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, var(--royal-gold-dark), var(--royal-gold));
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.6s ease-out; }
        .fade-out { animation: fadeOut 0.6s ease-out; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Enhanced Notifications */
        .notification-container {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            pointer-events: none;
        }

        .notification {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.95), rgba(32, 201, 151, 0.95));
            color: var(--text-white);
            padding: 18px 25px;
            border-radius: 12px;
            border-left: 4px solid var(--royal-gold);
            box-shadow:
                0 10px 25px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: slideInNotification 0.6s ease-out;
            min-width: 280px;
            max-width: 400px;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            font-weight: 500;
        }

        .notification.error {
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.95), rgba(255, 107, 107, 0.95));
        }

        .notification.warning {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.95), rgba(255, 235, 59, 0.95));
            color: var(--text-dark);
        }

        .notification.info {
            background: linear-gradient(135deg, rgba(25, 25, 112, 0.95), rgba(108, 92, 231, 0.95));
        }

        @keyframes slideInNotification {
            from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Enhanced Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(26, 26, 46, 0.98));
            border: 2px solid var(--royal-gold);
            border-radius: 20px;
            padding: 35px;
            max-width: 85vw;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(25px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--royal-gold);
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--royal-gold);
        }

        .modal-close {
            background: none;
            border: 2px solid #dc3545;
            color: #dc3545;
            border-radius: 8px;
            padding: 10px 18px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            user-select: none;
        }

        .modal-close:hover {
            background: #dc3545;
            color: var(--text-white);
            transform: scale(1.05);
        }

        /* Connection Status Enhanced */
        .connection-status {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            user-select: none;
        }

        .connection-status.connected {
            background: linear-gradient(45deg, rgba(40, 167, 69, 0.9), rgba(32, 201, 151, 0.9));
            color: white;
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .connection-status.disconnected {
            background: linear-gradient(45deg, rgba(220, 20, 60, 0.9), rgba(255, 107, 107, 0.9));
            color: white;
            border: 1px solid rgba(220, 20, 60, 0.5);
            animation: pulse 1s infinite;
        }

        .connection-status.connecting {
            background: linear-gradient(45deg, rgba(255, 193, 7, 0.9), rgba(255, 235, 59, 0.9));
            color: var(--text-dark);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        /* Mobile Responsiveness Enhanced */
        @media (max-width: 768px) {
            .menu-panel {
                min-width: 95vw;
                padding: 20px;
                max-height: 85vh;
            }

            .menu-title {
                font-size: 2.2rem;
            }

            .chat-panel {
                width: 95vw;
                max-height: 45vh;
                top: auto;
                bottom: 200px;
                left: 2.5vw;
                right: 2.5vw;
            }

            .actions-panel {
                bottom: 30px;
                gap: 12px;
                padding: 0 15px;
            }

            .premium-button {
                padding: 12px 20px;
                font-size: 0.9rem;
                min-width: 110px;
            }

            .player-hands {
                bottom: 220px;
                gap: 15px;
                padding: 0 15px;
            }

            .player-hand {
                min-width: 180px;
                padding: 15px;
            }

            .dealer-area {
                min-width: 320px;
                padding: 20px;
            }

            .game-hud {
                max-width: 320px;
                max-height: 55vh;
            }

            .bet-panel-custom-location {
                bottom: 240px; /* Adjust for mobile */
                left: 50%;
                transform: translateX(-50%);
                width: 90vw;
                max-width: 90vw; /* Ensure it doesn't get too small or too big */
            }

            .bet-controls {
                flex-direction: column;
                align-items: center;
                gap: 12px;
            }

            .loading-logo {
                font-size: 2.8rem;
            }
        }

        @media (max-width: 480px) {
            .menu-panel {
                min-width: 98vw;
                padding: 15px;
            }

            .premium-button {
                padding: 10px 18px;
                font-size: 0.85rem;
                min-width: 100px;
            }

            .chat-panel {
                max-height: 40vh;
            }

            .player-hand {
                min-width: 160px;
                padding: 12px;
            }

            .loading-logo {
                font-size: 2.2rem;
            }

            .dealer-title {
                font-size: 1.3rem;
            }

            .menu-title {
                font-size: 1.8rem;
            }
        }

        /* Floating Particles Effect */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.6) 0%, transparent 70%);
            border-radius: 50%;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            from {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            to {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Error Display */
        .error-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.95), rgba(255, 107, 107, 0.95));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
        }

        .error-display h3 {
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .error-display button {
            margin-top: 20px;
            padding: 12px 24px;
            background: white;
            color: #dc3545;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .error-display button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="animated-bg"></div>

    <!-- Floating Particles -->
    <div class="floating-particles" id="particles"></div>

    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">Connecting...</div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="logo-container">
            <div class="loading-logo">
                🎰 ROYAL BLACKJACK 3D 🎰
            </div>
        </div>
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading premium casino experience...</div>
    </div>

    <!-- Main Game Container -->
    <div id="gameContainer">
        <canvas id="canvas"></canvas>

        <!-- 2D Fallback Mode -->
        <div id="fallback2D" class="fallback-2d">
            <div class="fallback-table"></div>
        </div>

        <!-- UI Overlay -->
        <div class="ui-overlay">
            <!-- Main Menu -->
            <div id="menuPanel" class="ui-panel menu-panel hidden">
                <h1 class="menu-title">
                    🎰 ROYAL BLACKJACK 3D 🎰
                </h1>

                <div class="menu-section">
                    <h3>👤 Player Setup</h3>
                    <label for="playerName">Player Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your royal name" value="Royal Player" maxlength="20">
                </div>

                <div class="menu-section">
                    <h3>⚡ Quick Play</h3>
                    <button class="premium-button" onclick="createQuickRoom()" style="width: 100%; margin-bottom: 15px;">
                        🎯 Create Quick Room
                    </button>
                    <div style="display: flex; gap: 12px; margin-bottom: 15px;">
                        <input type="text" id="roomCodeInput" placeholder="Room Code" style="flex: 1; margin-bottom: 0;" maxlength="6">
                        <button class="premium-button" onclick="joinRoomFromInput()">🚪 Join</button>
                    </div>
                    <button class="premium-button" onclick="spectateRoomFromInput()" style="width: 100%;">
                        👁️ Spectate Room
                    </button>
                </div>

                <div class="menu-section">
                    <h3>🎪 Custom Game</h3>
                    <label for="roomName">Room Name (Optional):</label>
                    <input type="text" id="roomName" placeholder="Royal Casino Table" maxlength="30">
                    <button class="premium-button" onclick="createCustomRoom()" style="width: 100%; margin-top: 20px;">
                        🏛️ Create Custom Room
                    </button>
                </div>

                <div class="menu-section">
                    <h3>🏛️ Browse Rooms</h3>
                    <button class="premium-button" onclick="showRoomList()" style="width: 100%;">
                        🎲 Browse Public Rooms
                    </button>
                </div>
            </div>

            <!-- Room List Modal -->
            <div id="roomListModal" class="modal hidden">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2 class="modal-title">🏛️ Royal Gaming Rooms</h2>
                        <button class="modal-close" onclick="hideRoomList()">✕</button>
                    </div>
                    <div id="roomList" style="max-height: 60vh; overflow-y: auto;">
                        <div style="text-align: center; color: #ccc; padding: 30px;">
                            <div class="loading-spinner" style="margin: 0 auto 20px; width: 60px; height: 60px;"></div>
                            Loading royal rooms...
                        </div>
                    </div>
                    <div style="margin-top: 25px; text-align: center;">
                        <button class="premium-button" onclick="refreshRoomList()">🔄 Refresh</button>
                    </div>
                </div>
            </div>

            <!-- Game HUD -->
            <div id="gameHUD" class="ui-panel game-hud hidden">
                <div class="hud-item">
                    <span class="hud-label">🏠 Room:</span>
                    <span class="hud-value" id="currentRoomCodeDisplay">-</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">🎮 Phase:</span>
                    <span class="hud-value" id="phaseText">Waiting</span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">💰 Balance:</span>
                    <span class="hud-value">$<span id="moneyAmount">0</span></span>
                </div>
                <div class="hud-item">
                    <span class="hud-label">🃏 Hand #:</span>
                    <span class="hud-value" id="handNumber">0</span>
                </div>
                <div style="margin-top: 20px; display: flex; flex-direction: column; gap: 12px;">
                    <button class="premium-button" onclick="startGame()" id="startGameBtn" style="width: 100%;">
                        🚀 Start Game
                    </button>
                    <button class="premium-button button-surrender" onclick="leaveRoom()" id="leaveRoomBtn" style="width: 100%;">
                        🚪 Leave Room
                    </button>
                </div>
            </div>

            <!-- Dealer Area -->
            <div id="dealerArea" class="dealer-area hidden">
                <div class="dealer-title">🎩 ROYAL DEALER</div>
                <div class="dealer-hand" id="dealerHand"></div>
                <div class="dealer-value" id="dealerValue">Hidden</div>
            </div>

            <!-- Betting Controls -->
            <div id="betControls" class="ui-panel bet-panel-custom-location hidden">
                <div class="bet-controls">
                    <span class="bet-label">💰 Bet Amount:</span>
                    <div class="bet-buttons">
                        <button class="bet-button" onclick="setBetAmount(10)">$10</button>
                        <button class="bet-button" onclick="setBetAmount(25)">$25</button>
                        <button class="bet-button" onclick="setBetAmount(50)">$50</button>
                        <button class="bet-button" onclick="setBetAmount(100)">$100</button>
                        <button class="bet-button" onclick="setBetAmount(250)">$250</button>
                    </div>
                    <input type="number" id="betAmountInput" class="bet-input" min="10" max="500" value="25" step="5">
                    <button class="premium-button" onclick="placeBet()">💎 Place Bet</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div id="actionsPanel" class="actions-panel hidden">
                <button class="premium-button button-hit" onclick="playerAction('hit')" id="hitBtn">👆 Hit</button>
                <button class="premium-button button-stand" onclick="playerAction('stand')" id="standBtn">✋ Stand</button>
                <button class="premium-button button-double" onclick="playerAction('double_down')" id="doubleBtn">⚡ Double</button>
                <button class="premium-button button-split" onclick="playerAction('split')" id="splitBtn">✂️ Split</button>
                <button class="premium-button button-surrender" onclick="playerAction('surrender')" id="surrenderBtn">🏳️ Surrender</button>
            </div>

            <!-- Chat Panel -->
            <div id="chatPanel" class="chat-panel hidden">
                <div class="chat-header">
                    <h3 class="chat-title">💬 Royal Chat</h3>
                    <button class="chat-toggle" onclick="toggleChat()" id="chatToggle">−</button>
                </div>
                <div id="chatMessages"></div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Type royal message..."
                           onkeypress="handleChatKeyPress(event)" maxlength="200">
                    <button class="premium-button" onclick="sendChat()">Send</button>
                </div>
            </div>

            <!-- Player Hands Display -->
            <div id="playerHandsDisplay" class="player-hands hidden"></div>
        </div>
    </div>

    <!-- Notifications Container -->
    <div id="notificationContainer" class="notification-container"></div>

    <script>
        // Global Variables
        let ws = null;
        let scene, camera, renderer;
        let blackjackTable, tableGroup;
        let playerPositions = [];
        let cardMaterials = {}, chipMaterials = {};
        let currentGameState = null;
        let isConnected = false;
        let isPlayerInGame = false;
        let myPlayerId = null;
        let currentRoomCode = null;
        let cameraAnimating = false;
        let isLoadingOrReconnecting = false;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000;
        let use3D = true;
        let threeJSLoaded = false;
        let fallbackMode = false;

        let communityCardObjects = [];
        let playerCardObjects3D = {};
        let dealerCardObjects3D = [];
        let chipStackObjects = {};
        let particleSystem;
        let environmentLights = [];

        let chatCollapsed = false;
        let connectionStatusEl;

        // Enhanced Logging
        function consoleLog(message, ...params) {
            const timestamp = new Date().toISOString();
            console.log(`[RoyalBlackjack] ${timestamp} - ${message}`, ...params);
        }

        function consoleError(message, ...params) {
            const timestamp = new Date().toISOString();
            console.error(`[RoyalBlackjack ERROR] ${timestamp} - ${message}`, ...params);
        }

        function consoleWarn(message, ...params) {
            const timestamp = new Date().toISOString();
            console.warn(`[RoyalBlackjack WARN] ${timestamp} - ${message}`, ...params);
        }

        // Check Three.js availability
        function checkThreeJS() {
            return new Promise((resolve) => {
                if (typeof THREE !== 'undefined') {
                    threeJSLoaded = true;
                    resolve(true);
                    return;
                }

                // Wait for Three.js to load
                let attempts = 0;
                const checkInterval = setInterval(() => {
                    attempts++;
                    if (typeof THREE !== 'undefined') {
                        threeJSLoaded = true;
                        clearInterval(checkInterval);
                        resolve(true);
                    } else if (attempts > 50 || window.THREEJS_FAILED) { // 5 second timeout
                        clearInterval(checkInterval);
                        consoleWarn('Three.js failed to load, using 2D fallback');
                        resolve(false);
                    }
                }, 100);
            });
        }

        // Enhanced Connection Status Management
        function updateConnectionStatus(status, message = '') {
            if (!connectionStatusEl) {
                connectionStatusEl = document.getElementById('connectionStatus');
            }
            if (!connectionStatusEl) return;

            connectionStatusEl.className = `connection-status ${status}`;

            switch(status) {
                case 'connected':
                    connectionStatusEl.textContent = '🟢 Connected';
                    break;
                case 'connecting':
                    connectionStatusEl.textContent = '🟡 Connecting...';
                    break;
                case 'disconnected':
                    connectionStatusEl.textContent = '🔴 Disconnected';
                    break;
                case 'reconnecting':
                    connectionStatusEl.textContent = `🟡 Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`;
                    break;
            }

            if (message) {
                connectionStatusEl.title = message;
            }
        }

        // Enhanced Three.js Initialization with Better Error Handling
        async function initThreeJS() {
            consoleLog("Attempting to initialize 3D engine...");

            try {
                // Check if Three.js is available
                if (!threeJSLoaded || typeof THREE === 'undefined') {
                    throw new Error('Three.js library not available');
                }

                // Check WebGL support
                if (!window.WEBGL_SUPPORTED) {
                    throw new Error('WebGL not supported by this device');
                }

                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    throw new Error('Canvas element not found');
                }

                // Initialize Three.js components
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x0a0a1a, 20, 80);

                // Enhanced lighting setup
                setupPremiumLighting();

                // Camera with improved settings
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 15, 20);
                camera.lookAt(0, 0, 0);
                camera.userData = {
                    targetRotationY: 0,
                    targetDistance: 20,
                    targetHeight: 15,
                    smoothness: 0.05
                };

                // Enhanced renderer settings with error handling
                try {
                    renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: true,
                        alpha: true,
                        powerPreference: "high-performance",
                        stencil: false,
                        depth: true
                    });
                } catch (rendererError) {
                    // Fallback to basic renderer
                    renderer = new THREE.WebGLRenderer({ canvas: canvas });
                }

                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                try {
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.4;
                } catch (advancedError) {
                    consoleWarn('Advanced rendering features not supported, using basic mode');
                }

                // Create 3D scene elements
                createPremiumCasinoEnvironment();
                createLuxuryBlackjackTable();
                createPremiumCardMaterials();
                createLuxuryChipMaterials();
                addEnhancedMouseControls();
                createAdvancedParticleSystem();

                // Start animation loop
                animate();

                consoleLog("3D engine initialized successfully");
                use3D = true;
                return true;

            } catch (error) {
                consoleError("3D engine initialization failed:", error);
                showErrorWithFallback('3D engine initialization failed', error.message);
                return false;
            }
        }

        // Show error with 2D fallback option
        function showErrorWithFallback(title, message) {
            // Check if we should auto-fallback to 2D
            if (!fallbackMode) {
                fallbackMode = true;
                enable2DFallback();
                showNotification("3D mode unavailable, using 2D interface", "warning", 5000);
            }
        }

        // Enable 2D Fallback Mode
        function enable2DFallback() {
            consoleLog("Enabling 2D fallback mode");

            const canvas = document.getElementById('canvas');
            const fallback = document.getElementById('fallback2D');

            if (canvas) canvas.style.display = 'none';
            if (fallback) fallback.style.display = 'flex';

            use3D = false;

            // Create 2D floating particles
            createFloatingParticles();
        }

        // Simplified versions of 3D functions for fallback
        function setupPremiumLighting() {
            if (!scene || !THREE) return;

            try {
                // Ambient lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);

                // Main directional light
                const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
                mainLight.position.set(20, 30, 20);
                mainLight.castShadow = true;
                scene.add(mainLight);

                // Table spotlight
                const tableSpotlight = new THREE.SpotLight(0xffd700, 3.0, 50, Math.PI / 4, 0.3, 2);
                tableSpotlight.position.set(0, 25, 0);
                tableSpotlight.target.position.set(0, 0, 0);
                scene.add(tableSpotlight);
                scene.add(tableSpotlight.target);

                // Rim lighting
                const rimLight1 = new THREE.DirectionalLight(0x4169e1, 0.8);
                rimLight1.position.set(-15, 8, -15);
                scene.add(rimLight1);

                const rimLight2 = new THREE.DirectionalLight(0xdc143c, 0.6);
                rimLight2.position.set(15, 8, 15);
                scene.add(rimLight2);

                // Point lights for ambiance
                const colors = [0xffd700, 0xff4757, 0x3742fa, 0x2ed573];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const pointLight = new THREE.PointLight(colors[i % colors.length], 0.5, 20);
                    pointLight.position.set(
                        Math.cos(angle) * 15,
                        12 + Math.sin(i) * 3,
                        Math.sin(angle) * 15
                    );
                    scene.add(pointLight);
                    environmentLights.push(pointLight);
                }
            } catch (error) {
                consoleWarn('Error setting up lighting:', error);
            }
        }

        function createPremiumCasinoEnvironment() {
            if (!scene || !THREE) return;

            try {
                // Floor
                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a2e, transparent: true, opacity: 0.9 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -3;
                floor.receiveShadow = true;
                scene.add(floor);

                // Skybox
                const skyboxGeometry = new THREE.SphereGeometry(200, 32, 32);
                const skyboxMaterial = new THREE.MeshBasicMaterial({ color: 0x0a0a1a, side: THREE.BackSide, fog: false });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                scene.add(skybox);
            } catch (error) {
                consoleWarn('Error creating environment:', error);
            }
        }

        function createLuxuryBlackjackTable() {
            if (!scene || !THREE) return;

            try {
                tableGroup = new THREE.Group();

                // Table base
                const tableGeometry = new THREE.CylinderGeometry(7, 7, 0.6, 32);
                const tableMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 30 });
                blackjackTable = new THREE.Mesh(tableGeometry, tableMaterial);
                blackjackTable.position.y = -0.3;
                blackjackTable.receiveShadow = true;
                blackjackTable.castShadow = true;
                tableGroup.add(blackjackTable);

                // Table edge
                const edgeGeometry = new THREE.TorusGeometry(7, 0.4, 16, 32);
                const goldMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700, shininess: 80 });
                const tableEdge = new THREE.Mesh(edgeGeometry, goldMaterial);
                tableEdge.rotation.x = Math.PI / 2;
                tableEdge.position.y = 0;
                tableEdge.castShadow = true;
                tableGroup.add(tableEdge);

                // Felt surface
                const feltGeometry = new THREE.CylinderGeometry(6.5, 6.5, 0.1, 32);
                const feltMaterial = new THREE.MeshLambertMaterial({ color: 0x0d4d2a });
                const tableFelt = new THREE.Mesh(feltGeometry, feltMaterial);
                tableFelt.position.y = 0.05;
                tableFelt.receiveShadow = true;
                tableGroup.add(tableFelt);

                createPlayerPositions();
                scene.add(tableGroup);
            } catch (error) {
                consoleWarn('Error creating table:', error);
            }
        }

        function createPlayerPositions() {
            playerPositions = [];
            const radius = 5.2;
            const angleStep = Math.PI / 7;
            const startAngle = Math.PI + angleStep / 2;

            for (let i = 0; i < 6; i++) {
                const angle = startAngle + i * angleStep;
                playerPositions.push({
                    angle: angle,
                    x: Math.cos(angle) * radius,
                    z: Math.sin(angle) * radius,
                    cardXOffset: 0,
                    cardSpacing: 0.8,
                    chipX: Math.cos(angle) * (radius - 1.5),
                    chipZ: Math.sin(angle) * (radius - 1.5)
                });
            }
        }

        function createPremiumCardMaterials() {
            if (!THREE) return;
            try {
                cardMaterials.back = new THREE.MeshPhongMaterial({ color: 0x1e3a8a, shininess: 40 });
            } catch (error) {
                consoleWarn('Error creating card materials:', error);
            }
        }

        function createLuxuryChipMaterials() {
            if (!THREE) return;
            try {
                const colors = [0xFFFFFF, 0x22C55E, 0xEF4444, 0x1F2937, 0x8B5CF6, 0xF59E0B];
                const denominations = [10, 25, 50, 100, 250, 500];

                denominations.forEach((denom, index) => {
                    chipMaterials[denom] = new THREE.MeshPhongMaterial({
                        color: colors[index],
                        shininess: 60
                    });
                });

                chipMaterials['default'] = new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 50 });
            } catch (error) {
                consoleWarn('Error creating chip materials:', error);
            }
        }

        function createAdvancedParticleSystem() {
            if (!scene || !THREE) return;

            try {
                const particleCount = 200;
                const particles = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                const particleColors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    particlePositions[i3] = (Math.random() - 0.5) * 120;
                    particlePositions[i3 + 1] = Math.random() * 40 + 5;
                    particlePositions[i3 + 2] = (Math.random() - 0.5) * 120;

                    const color = new THREE.Color();
                    color.setHSL(0.15 + Math.random() * 0.1, 0.8, 0.4 + Math.random() * 0.4);
                    particleColors[i3] = color.r;
                    particleColors[i3 + 1] = color.g;
                    particleColors[i3 + 2] = color.b;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.15,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    fog: false,
                    vertexColors: true
                });

                particleSystem = new THREE.Points(particles, particleMaterial);
                scene.add(particleSystem);
            } catch (error) {
                consoleWarn('Error creating particle system:', error);
            }
        }

        function createFloatingParticles() {
            const particlesContainer = document.getElementById('particles');
            if (!particlesContainer) return;

            const particleCount = 15;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                particle.style.width = (Math.random() * 4 + 2) + 'px';
                particle.style.height = particle.style.width;
                particlesContainer.appendChild(particle);
            }
        }

        function addEnhancedMouseControls() {
            if (!use3D || !camera) return;

            let mouseDown = false, lastMouseX = 0, lastMouseY = 0;
            let touchStartX = 0, touchStartY = 0;
            const menuPanel = document.getElementById('menuPanel');
            const canvasEl = document.getElementById('canvas');

            if (!canvasEl) return;

            canvasEl.addEventListener('mousedown', (event) => {
                if (menuPanel && menuPanel.classList.contains('hidden')) {
                    mouseDown = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (mouseDown && menuPanel && menuPanel.classList.contains('hidden') && !cameraAnimating) {
                    const deltaX = event.clientX - lastMouseX;
                    const deltaY = event.clientY - lastMouseY;

                    camera.userData.targetRotationY -= deltaX * 0.003;
                    camera.userData.targetHeight = camera.userData.targetHeight || 15;
                    camera.userData.targetHeight += deltaY * 0.015;
                    camera.userData.targetHeight = Math.max(8, Math.min(25, camera.userData.targetHeight));
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                }
            });

            // Touch controls
            canvasEl.addEventListener('touchstart', (event) => {
                if (menuPanel && menuPanel.classList.contains('hidden') && event.touches.length === 1) {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    event.preventDefault();
                }
            });

            canvasEl.addEventListener('touchmove', (event) => {
                if (menuPanel && menuPanel.classList.contains('hidden') && event.touches.length === 1 && !cameraAnimating) {
                    const deltaX = event.touches[0].clientX - touchStartX;
                    const deltaY = event.touches[0].clientY - touchStartY;

                    camera.userData.targetRotationY -= deltaX * 0.008;
                    camera.userData.targetHeight = camera.userData.targetHeight || 15;
                    camera.userData.targetHeight += deltaY * 0.03;
                    camera.userData.targetHeight = Math.max(8, Math.min(25, camera.userData.targetHeight));

                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    event.preventDefault();
                }
            });

            // Mouse wheel zoom
            canvasEl.addEventListener('wheel', (event) => {
                if (menuPanel && menuPanel.classList.contains('hidden') && !cameraAnimating) {
                    event.preventDefault();
                    camera.userData.targetDistance += event.deltaY * 0.015;
                    camera.userData.targetDistance = Math.max(8, Math.min(40, camera.userData.targetDistance));
                }
            });
        }

        function animate() {
            if (!use3D || !renderer || !scene || !camera) return;

            requestAnimationFrame(animate);
            const currentTime = Date.now() * 0.001;

            try {
                // Camera movement
                if (!cameraAnimating && camera.userData) {
                    const lerpFactor = camera.userData.smoothness || 0.05;
                    const targetHeight = camera.userData.targetHeight || 15;
                    const targetDistance = camera.userData.targetDistance || 20;

                    camera.position.x = THREE.MathUtils.lerp(
                        camera.position.x,
                        Math.sin(camera.userData.targetRotationY) * targetDistance,
                        lerpFactor
                    );
                    camera.position.z = THREE.MathUtils.lerp(
                        camera.position.z,
                        Math.cos(camera.userData.targetRotationY) * targetDistance,
                        lerpFactor
                    );
                    camera.position.y = THREE.MathUtils.lerp(
                        camera.position.y,
                        targetHeight + (targetDistance - 20) * 0.1,
                        lerpFactor
                    );
                    camera.lookAt(0, 0, 0);
                }

                // Particle system animation
                if (particleSystem && particleSystem.geometry.attributes.position) {
                    particleSystem.rotation.y += 0.0002;
                    const positions = particleSystem.geometry.attributes.position.array;

                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += Math.sin(currentTime + i * 0.01) * 0.003;
                        if (positions[i] < 5) positions[i] = 5 + Math.random() * 30;
                        if (positions[i] > 45) positions[i] = 45 - Math.random() * 30;
                    }

                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Environment lights animation
                environmentLights.forEach((light, index) => {
                    if (light.intensity !== undefined) {
                        const intensity = 0.5 + Math.sin(currentTime * 0.5 + index) * 0.2;
                        light.intensity = intensity;
                    }
                });

                renderer.render(scene, camera);
            } catch (error) {
                consoleWarn('Animation error:', error);
            }
        }

        // Simplified stubs for 3D functions when in 2D mode
        function updateTableVisuals() {
            if (!use3D) {
                // In 2D mode, we update the UI instead
                return;
            }
            // 3D table visual updates would go here
        }

        function clearAll3DObjects() {
            if (!use3D) return;
            // Clear 3D objects
        }

        function animateCameraToTable() {
            if (!use3D || !camera) return;

            consoleLog("Animating camera to table view");
            cameraAnimating = true;
            camera.userData.targetRotationY = 0;
            camera.userData.targetDistance = 20;
            camera.userData.targetHeight = 15;

            if (typeof gsap !== 'undefined') {
                gsap.to(camera.position, {
                    duration: 2,
                    x: 0,
                    y: 15,
                    z: 20,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, 0, 0),
                    onComplete: () => {
                        cameraAnimating = false;
                    }
                });
            } else {
                // Fallback without GSAP
                camera.position.set(0, 15, 20);
                camera.lookAt(0, 0, 0);
                cameraAnimating = false;
            }
        }

        function animateCameraToMenu() {
            if (!use3D || !camera) return;

            consoleLog("Animating camera to menu view");
            cameraAnimating = true;
            camera.userData.targetRotationY = Math.PI / 5;
            camera.userData.targetDistance = 28;
            camera.userData.targetHeight = 20;

            if (typeof gsap !== 'undefined') {
                gsap.to(camera.position, {
                    duration: 2,
                    x: 12,
                    y: 20,
                    z: 28,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, 0, 0),
                    onComplete: () => {
                        cameraAnimating = false;
                    }
                });
            } else {
                // Fallback without GSAP
                camera.position.set(12, 20, 28);
                camera.lookAt(0, 0, 0);
                cameraAnimating = false;
            }
        }

        // WebSocket and Game Logic (simplified for space)
        function connectWebSocket() {
            consoleLog("Establishing connection...");
            if (isLoadingOrReconnecting && ws && ws.readyState === WebSocket.CONNECTING) {
                consoleLog("Connection already in progress");
                return;
            }

            isLoadingOrReconnecting = true;
            updateConnectionStatus('connecting');

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                ws.close();
            }

            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                consoleLog('Connection established');
                isConnected = true;
                isLoadingOrReconnecting = false;
                reconnectAttempts = 0;
                hideLoadingScreen();
                updateConnectionStatus('connected');
                showNotification('🎰 Welcome to Royal Blackjack 3D!', 'success', 4000);
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    consoleLog('Message received:', message.type);
                    handleServerMessage(message);
                } catch (e) {
                    consoleError("Error parsing server message:", e, event.data);
                    showNotification('Invalid server response', 'error');
                }
            };

            ws.onclose = function(event) {
                consoleLog(`Connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                isConnected = false;
                updateConnectionStatus('disconnected', `Code: ${event.code}`);

                clearAll3DObjects();
                if (!isLoadingOrReconnecting) {
                    showMainMenu();
                    animateCameraToMenu();
                }

                if (reconnectAttempts < maxReconnectAttempts && !isLoadingOrReconnecting) {
                    reconnectAttempts++;
                    const delay = Math.min(reconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000);
                    updateConnectionStatus('reconnecting');
                    showLoadingScreen(`Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`);
                    showNotification(`Reconnecting... Attempt ${reconnectAttempts}`, 'warning');

                    setTimeout(() => {
                        if (!isConnected) {
                            connectWebSocket();
                        }
                    }, delay);
                } else if (reconnectAttempts >= maxReconnectAttempts) {
                    updateConnectionStatus('disconnected', 'Max reconnect attempts reached');
                    showNotification('Connection lost. Please refresh the page.', 'error', 10000);
                }
            };

            ws.onerror = function(error) {
                consoleError('WebSocket error:', error);
                updateConnectionStatus('disconnected', 'Connection error');
                showNotification('Connection error occurred', 'error');
            };
        }

        function sendMessage(action, payload = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = { action, payload };
                consoleLog('Sending message:', action, payload);
                try {
                    ws.send(JSON.stringify(message));
                    return true;
                } catch (e) {
                    consoleError('Error sending message:', e);
                    showNotification('Failed to send message', 'error');
                    return false;
                }
            } else {
                consoleError('WebSocket not connected:', ws ? ws.readyState : 'null');
                showNotification('Not connected to server', 'warning');
                return false;
            }
        }

        function handleServerMessage(message) {
            try {
                switch (message.type) {
                    case 'connected':
                        myPlayerId = message.data.player_id;
                        consoleLog(`Connected as player: ${myPlayerId}`);
                        hideLoadingScreen();
                        showMainMenu();
                        break;

                    case 'room_created':
                    case 'room_joined':
                        currentRoomCode = message.data.room_code;
                        isPlayerInGame = true;
                        hideLoadingScreen();
                        showGameInterface();
                        showNotification(`🏛️ Joined Room: ${currentRoomCode}`, 'success');
                        animateCameraToTable();
                        break;

                    case 'spectating':
                        currentRoomCode = message.data.room_code;
                        isPlayerInGame = false;
                        hideLoadingScreen();
                        showGameInterface();
                        showNotification(`👁️ Spectating: ${currentRoomCode}`, 'info');
                        animateCameraToTable();
                        break;

                    case 'room_left':
                        hideLoadingScreen();
                        handleRoomLeft();
                        break;

                    case 'game_state':
                        currentGameState = message.data;
                        updateGameInterface();
                        break;

                    case 'room_list':
                        updateRoomList(message.data.rooms);
                        break;

                    case 'error':
                        consoleError('Server error:', message.message);
                        showNotification('❌ ' + message.message, 'error');
                        hideLoadingScreen();
                        break;

                    default:
                        consoleWarn('Unknown message type:', message.type);
                }
            } catch (e) {
                consoleError('Error handling server message:', e, message);
                showNotification('Error processing server response', 'error');
            }
        }

        function handleRoomLeft() {
            showMainMenu();
            showNotification('👋 Left room', 'info');
            animateCameraToMenu();
            currentRoomCode = null;
            currentGameState = null;
            isPlayerInGame = false;
            clearAll3DObjects();
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                if (typeof gsap !== 'undefined') {
                    gsap.to(loadingScreen, {
                        duration: 1,
                        opacity: 0,
                        scale: 0.9,
                        ease: "power2.out",
                        onComplete: () => {
                            loadingScreen.style.display = 'none';
                            consoleLog("Loading screen hidden");
                        }
                    });
                } else {
                    loadingScreen.style.display = 'none';
                    consoleLog("Loading screen hidden");
                }
            }
        }

        function showLoadingScreen(text = 'Loading premium experience...') {
            const loadingScreen = document.getElementById('loadingScreen');
            const textElement = loadingScreen.querySelector('.loading-text');
            if (textElement) textElement.textContent = text;

            loadingScreen.style.display = 'flex';
            loadingScreen.style.opacity = '0';

            if (typeof gsap !== 'undefined') {
                gsap.to(loadingScreen, {
                    duration: 0.6,
                    opacity: 1,
                    scale: 1,
                    ease: "power2.out"
                });
            } else {
                loadingScreen.style.opacity = '1';
            }

            consoleLog("Loading screen shown:", text);
        }

        function showMainMenu() {
            consoleLog("Showing main menu");
            const menuPanel = document.getElementById('menuPanel');
            if (menuPanel) {
                menuPanel.classList.remove('hidden');
            }

            ['gameHUD', 'dealerArea', 'betControls', 'actionsPanel', 'chatPanel', 'playerHandsDisplay'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.classList.add('hidden');
            });

            clearAll3DObjects();

            if (typeof gsap !== 'undefined' && menuPanel) {
                gsap.fromTo(menuPanel,
                    { opacity: 0, scale: 0.8, y: 50 },
                    { opacity: 1, scale: 1, y: 0, duration: 0.8, ease: "back.out(1.4)" }
                );
            }
        }

        function showGameInterface() {
            consoleLog("Showing game interface");
            const menuPanel = document.getElementById('menuPanel');
            if (menuPanel) {
                menuPanel.classList.add('hidden');
            }

            ['gameHUD', 'dealerArea', 'chatPanel', 'playerHandsDisplay'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.classList.remove('hidden');
            });

            if (typeof gsap !== 'undefined') {
                gsap.fromTo(['#gameHUD', '#dealerArea', '#chatPanel'],
                    { opacity: 0, y: -30 },
                    { opacity: 1, y: 0, duration: 0.6, ease: "power2.out", stagger: 0.1 }
                );
            }
        }

        function updateGameInterface() {
            if (!currentGameState) return;

            consoleLog("Updating game interface");

            // Update HUD
            const roomDisplay = document.getElementById('currentRoomCodeDisplay');
            const phaseText = document.getElementById('phaseText');
            const handNumber = document.getElementById('handNumber');
            const moneyAmount = document.getElementById('moneyAmount');

            if (roomDisplay) roomDisplay.textContent = currentGameState.room_code || '-';
            if (phaseText) phaseText.textContent = currentGameState.phase.replace(/_/g, ' ').toUpperCase();
            if (handNumber) handNumber.textContent = currentGameState.hand_number || '0';

            const myPlayerState = currentGameState.players[myPlayerId];
            if (moneyAmount) {
                if (myPlayerState) {
                    moneyAmount.textContent = myPlayerState.money.toLocaleString();
                } else {
                    moneyAmount.textContent = 'N/A (Spectator)';
                }
            }

            // Show appropriate controls
            if (currentGameState.phase === 'waiting' && myPlayerState && isPlayerInGame && myPlayerState.hands[0]?.bet_amount === 0) {
                showElement('betControls');
                hideElement('actionsPanel');
            } else if (currentGameState.can_act && currentGameState.available_actions && isPlayerInGame) {
                hideElement('betControls');
                showElement('actionsPanel');
                updateActionButtons();
            } else {
                hideElement('betControls');
                hideElement('actionsPanel');
            }

            updateDealerDisplay();
            updatePlayerHandsUI();
            updateChat();
            updateTableVisuals();

            // Start button logic
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn) {
                const canStartGame = currentGameState.phase === 'waiting' &&
                                     myPlayerState &&
                                     myPlayerState.id === currentGameState.owner_id &&
                                     Object.values(currentGameState.players).some(p => p.hands[0]?.bet_amount > 0);

                if (canStartGame) {
                    startBtn.style.display = 'block';
                    if (typeof gsap !== 'undefined') {
                        gsap.fromTo(startBtn,
                            { scale: 0.8 },
                            { scale: 1, duration: 0.4, ease: "back.out(1.7)" }
                        );
                    }
                } else {
                    startBtn.style.display = 'none';
                }
            }
        }

        function showElement(elementId) {
            const element = document.getElementById(elementId);
            if (element && element.classList.contains('hidden')) {
                element.classList.remove('hidden');
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(element,
                        { opacity: 0, y: 30 },
                        { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
                    );
                }
            }
        }

        function hideElement(elementId) {
            const element = document.getElementById(elementId);
            if (element && !element.classList.contains('hidden')) {
                if (typeof gsap !== 'undefined') {
                    gsap.to(element, {
                        opacity: 0,
                        y: -30,
                        duration: 0.4,
                        ease: "power2.in",
                        onComplete: () => element.classList.add('hidden')
                    });
                } else {
                    element.classList.add('hidden');
                }
            }
        }

        function updateDealerDisplay() {
            const dealerHandEl = document.getElementById('dealerHand');
            const dealerValueEl = document.getElementById('dealerValue');

            if (!dealerHandEl || !dealerValueEl) return;

            if (!currentGameState.dealer_hand || !currentGameState.dealer_hand.cards) {
                dealerHandEl.innerHTML = '';
                dealerValueEl.textContent = 'No cards';
                return;
            }

            dealerHandEl.innerHTML = '';

            currentGameState.dealer_hand.cards.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card-mini';

                if (card.suit === 'back') {
                    cardDiv.classList.add('back');
                    cardDiv.textContent = '?';
                } else {
                    if (card.suit === 'hearts' || card.suit === 'diamonds') {
                        cardDiv.classList.add('red');
                    }
                    cardDiv.textContent = card.rank;
                }

                dealerHandEl.appendChild(cardDiv);

                // Animation
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(cardDiv,
                        { opacity: 0, scale: 0, rotationY: 180 },
                        { opacity: 1, scale: 1, rotationY: 0, duration: 0.6, delay: index * 0.15, ease: "back.out(1.7)" }
                    );
                }
            });

            if (currentGameState.dealer_hand.value !== null && currentGameState.dealer_hand.value !== undefined) {
                const newValue = `Value: ${currentGameState.dealer_hand.value}`;
                if (dealerValueEl.textContent !== newValue) {
                    if (typeof gsap !== 'undefined') {
                        gsap.fromTo(dealerValueEl,
                            { scale: 1.3, color: '#ffd700' },
                            { scale: 1, color: '#ffffff', duration: 0.6, ease: "power2.out", overwrite: "auto" }
                        );
                    }
                }
                dealerValueEl.textContent = newValue;
            } else {
                dealerValueEl.textContent = 'Hidden';
            }
        }

        function updateActionButtons() {
            if (!currentGameState.available_actions) return;

            const actions = currentGameState.available_actions;
            const buttonIds = ['hitBtn', 'standBtn', 'doubleBtn', 'splitBtn', 'surrenderBtn'];

            // Hide all buttons first
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
            });

            // Show available actions with animations
            actions.forEach((actionData, index) => {
                const btnId = actionData.action + 'Btn';
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.style.display = 'inline-block';
                    btn.disabled = false;

                    if (typeof gsap !== 'undefined') {
                        gsap.fromTo(btn,
                            { opacity: 0, scale: 0.8, y: 30 },
                            {
                                opacity: 1,
                                scale: 1,
                                y: 0,
                                duration: 0.5,
                                delay: index * 0.1,
                                ease: "back.out(1.7)",
                                overwrite: "auto"
                            }
                        );
                    }
                }
            });
        }

        function updatePlayerHandsUI() {
            const container = document.getElementById('playerHandsDisplay');
            if (!container) return;

            container.innerHTML = '';

            if (!currentGameState.players) return;

            Object.values(currentGameState.players).forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-hand';

                // Status classes
                if (player.is_current_player) playerDiv.classList.add('current-player');
                if (player.status === 'bust') playerDiv.classList.add('bust');
                if (player.status === 'blackjack') playerDiv.classList.add('blackjack');
                if (player.id === myPlayerId) {
                    playerDiv.style.borderColor = '#00ffff';
                    playerDiv.style.boxShadow = '0 0 30px rgba(0, 255, 255, 0.5)';
                }

                let handsHtml = '';
                player.hands.forEach((hand, handIndex) => {
                    const cardsHtml = hand.cards.map(card =>
                        `<div class="${(card.suit === 'hearts' || card.suit === 'diamonds') ? 'card-mini red' : card.suit === 'back' ? 'card-mini back' : 'card-mini'}">${card.suit === 'back' ? '?' : card.rank}</div>`
                    ).join('');

                    handsHtml += `
                        <div class="hand-info" style="border-top: ${handIndex > 0 ? '1px solid rgba(255,215,0,0.3)' : 'none'}; margin-top: ${handIndex > 0 ? '12px' : '0'}; padding-top: ${handIndex > 0 ? '12px' : '0'};">
                            <div class="hand-cards">${cardsHtml}</div>
                            <div><strong>Value:</strong> ${hand.value !== undefined ? hand.value : 'N/A'}</div>
                            <div><strong>Bet:</strong> ${hand.bet_amount}</div>
                            ${hand.result ? `<div style="color: ${getResultColor(hand.result)}; font-weight: bold; text-transform: uppercase;">${hand.result}</div>` : ''}
                            ${hand.payout > 0 && hand.result !== 'push' ? `<div style="color: #00ffaa; font-weight: bold;">Won: ${hand.payout - hand.bet_amount}</div>` : ''}
                            ${hand.payout > 0 && hand.result === 'push' ? `<div style="color: #ffaa00; font-weight: bold;">Push: ${hand.bet_amount} returned</div>` : ''}
                        </div>
                    `;
                });

                playerDiv.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-money">💰 ${player.money.toLocaleString()}</div>
                    ${handsHtml}
                `;

                container.appendChild(playerDiv);

                // Animation
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(playerDiv,
                        { opacity: 0, scale: 0.9, y: 20 },
                        { opacity: 1, scale: 1, y: 0, duration: 0.5, delay: index * 0.08, ease: "power2.out", overwrite: "auto" }
                    );
                }
            });
        }

        function getResultColor(result) {
            switch(result) {
                case 'win':
                case 'blackjack':
                    return '#00ff88';
                case 'lose':
                case 'bust':
                    return '#ff4757';
                case 'push':
                    return '#ffa502';
                default:
                    return '#ffffff';
            }
        }

        function updateChat() {
            if (!currentGameState || !currentGameState.chat_messages) return;

            const chatMessagesEl = document.getElementById('chatMessages');
            if (!chatMessagesEl) return;

            const shouldScroll = chatMessagesEl.scrollHeight - chatMessagesEl.clientHeight <= chatMessagesEl.scrollTop + 30;

            const currentMessageCount = chatMessagesEl.children.length;
            const newMessages = currentGameState.chat_messages;

            if (currentMessageCount !== newMessages.length ||
                (newMessages.length > 0 && chatMessagesEl.lastChild?.textContent !== newMessages[newMessages.length-1].message)) {

                chatMessagesEl.innerHTML = '';

                newMessages.forEach((msg, index) => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'chat-message';
                    msgDiv.style.borderLeftColor = msg.player_color || '#ffd700';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'chat-player-name';
                    nameSpan.style.color = msg.player_color || '#ffd700';
                    nameSpan.textContent = msg.player_name + ': ';

                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = msg.message;

                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'chat-timestamp';
                    timeSpan.textContent = msg.formatted_time;

                    msgDiv.appendChild(nameSpan);
                    msgDiv.appendChild(messageSpan);
                    msgDiv.appendChild(timeSpan);
                    chatMessagesEl.appendChild(msgDiv);

                    if (typeof gsap !== 'undefined') {
                        gsap.fromTo(msgDiv,
                            { opacity: 0, x: 30, scale: 0.9 },
                            { opacity: 1, x: 0, scale: 1, duration: 0.4, ease: "power2.out", delay: index * 0.03, overwrite: "auto" }
                        );
                    }
                });

                if (shouldScroll || !chatCollapsed) {
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                }
            }
        }

        // Game Action Functions
        function createQuickRoom() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput ? nameInput.value.trim() : '';
            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                if (nameInput) nameInput.focus();
                return;
            }
            if (sendMessage('create_room', { player_name: name })) {
                showLoadingScreen('Creating your royal room...');
            }
        }

        function createCustomRoom() {
            const nameInput = document.getElementById('playerName');
            const roomNameInput = document.getElementById('roomName');
            const name = nameInput ? nameInput.value.trim() : '';
            const roomName = roomNameInput ? roomNameInput.value.trim() : '';

            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                if (nameInput) nameInput.focus();
                return;
            }
            if (sendMessage('create_room', { player_name: name, room_name: roomName || null })) {
                showLoadingScreen('Creating your custom royal room...');
            }
        }

        function joinRoomFromInput() {
            const codeInput = document.getElementById('roomCodeInput');
            const nameInput = document.getElementById('playerName');
            const code = codeInput ? codeInput.value.trim().toUpperCase() : '';
            const name = nameInput ? nameInput.value.trim() : '';

            if (!code) {
                showNotification("🏛️ Please enter room code", "warning");
                if (codeInput) codeInput.focus();
                return;
            }
            if (!name) {
                showNotification("🤴 Please enter your royal name", "warning");
                if (nameInput) nameInput.focus();
                return;
            }
            if (sendMessage('join_room', { room_code: code, player_name: name })) {
                showLoadingScreen('Joining royal room...');
            }
        }

        function spectateRoomFromInput() {
            const codeInput = document.getElementById('roomCodeInput');
            const code = codeInput ? codeInput.value.trim().toUpperCase() : '';
            if (!code) {
                showNotification("🏛️ Please enter room code", "warning");
                if (codeInput) codeInput.focus();
                return;
            }
            if (sendMessage('spectate_room', { room_code: code })) {
                showLoadingScreen('Joining as royal spectator...');
            }
        }

        function leaveRoom() {
            if (confirm("Are you sure you want to leave this royal room?")) {
                if (sendMessage('leave_room')) {
                    showLoadingScreen('Leaving royal room...');
                }
            }
        }

        function startGame() {
            if (sendMessage('start_game')) {
                showNotification('🚀 Starting royal game...', 'info');
            }
        }

        // Betting Functions
        const MIN_BET_DYNAMIC = () => currentGameState?.min_bet || 10;
        const MAX_BET_DYNAMIC = () => currentGameState?.max_bet || 500;

        function setBetAmount(amount) {
            const input = document.getElementById('betAmountInput');
            if (input) {
                input.value = amount;

                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(input,
                        { scale: 1.1, borderColor: '#ffd700', boxShadow: '0 0 20px rgba(255, 215, 0, 0.6)' },
                        { scale: 1, borderColor: 'var(--royal-gold)', boxShadow: '0 0 15px rgba(255, 215, 0, 0.3)', duration: 0.4, ease: "power2.out", overwrite: "auto" }
                    );
                }
            }
        }

        function placeBet() {
            const input = document.getElementById('betAmountInput');
            const amount = input ? parseInt(input.value) : 0;

            if (isNaN(amount) || amount < MIN_BET_DYNAMIC() || amount > MAX_BET_DYNAMIC()) {
                showNotification(`💰 Bet must be ${MIN_BET_DYNAMIC()}-${MAX_BET_DYNAMIC()}`, "warning");
                return;
            }

            const myPlayerState = currentGameState.players[myPlayerId];
            if (myPlayerState && amount > myPlayerState.money) {
                showNotification("💸 Insufficient royal funds", "error");
                return;
            }

            if (sendMessage('player_action', { action_type: 'place_bet', amount: amount })) {
                showNotification(`💎 Royal bet placed: ${amount}`, 'success');
                hideElement('betControls');
            }
        }

        function playerAction(actionType) {
            if (sendMessage('player_action', { action_type: actionType })) {
                const actionNames = {
                    'hit': '👆 HIT',
                    'stand': '✋ STAND',
                    'double_down': '⚡ DOUBLE DOWN',
                    'split': '✂️ SPLIT',
                    'surrender': '🏳️ SURRENDER'
                };
                showNotification(`🎯 ${actionNames[actionType] || actionType.toUpperCase()}`, 'info');
            }
        }

        // Chat Functions
        function sendChat() {
            const input = document.getElementById('chatInput');
            if (!input) return;

            const message = input.value.trim();
            if (!message) return;

            if (message.length > 200) {
                showNotification("💬 Message too long", "warning");
                return;
            }

            if (sendMessage('send_chat_message', { message: message })) {
                input.value = '';
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(input,
                        { backgroundColor: 'rgba(0, 255, 0, 0.2)' },
                        { backgroundColor: 'var(--glass-bg)', duration: 0.6, overwrite: "auto" }
                    );
                }
            }
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                sendChat();
            }
        }

        function toggleChat() {
            chatCollapsed = !chatCollapsed;
            const chatPanel = document.getElementById('chatPanel');
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.querySelector('.chat-input-container');
            const chatToggle = document.getElementById('chatToggle');

            if (!chatPanel || !chatMessages || !chatInput || !chatToggle) return;

            const originalHeight = chatPanel.dataset.originalHeight || '300px';
            if (!chatPanel.dataset.originalHeight) {
                chatPanel.dataset.originalHeight = chatPanel.offsetHeight + 'px';
            }

            if (chatCollapsed) {
                if (typeof gsap !== 'undefined') {
                    gsap.to([chatMessages, chatInput], {
                        height: 0,
                        opacity: 0,
                        duration: 0.4,
                        onComplete: () => {
                            chatMessages.style.display = 'none';
                            chatInput.style.display = 'none';
                        }
                    });
                    gsap.to(chatPanel, { height: '60px', duration: 0.4 });
                } else {
                    chatMessages.style.display = 'none';
                    chatInput.style.display = 'none';
                    chatPanel.style.height = '60px';
                }
                chatToggle.textContent = '+';
            } else {
                chatMessages.style.display = 'block';
                chatInput.style.display = 'flex';

                if (typeof gsap !== 'undefined') {
                    gsap.set(chatMessages, { height: 'auto' });
                    const targetHeight = chatMessages.offsetHeight;
                    gsap.set(chatMessages, { height: 0 });

                    gsap.to(chatPanel, { height: originalHeight, duration: 0.4 });
                    gsap.to(chatMessages, { height: targetHeight, opacity: 1, duration: 0.4 });
                    gsap.to(chatInput, { height: 'auto', opacity: 1, duration: 0.4 });
                } else {
                    chatPanel.style.height = originalHeight;
                    chatMessages.style.opacity = '1';
                    chatInput.style.opacity = '1';
                }

                chatToggle.textContent = '−';

                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 100);
            }
        }

        // Room List Functions
        function showRoomList() {
            const modal = document.getElementById('roomListModal');
            if (modal) {
                modal.classList.remove('hidden');
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(modal,
                        { opacity: 0, scale: 0.9 },
                        { opacity: 1, scale: 1, duration: 0.4 }
                    );
                }
                refreshRoomList();
            }
        }

        function hideRoomList() {
            const modal = document.getElementById('roomListModal');
            if (modal) {
                if (typeof gsap !== 'undefined') {
                    gsap.to(modal, {
                        opacity: 0,
                        scale: 0.9,
                        duration: 0.4,
                        onComplete: () => modal.classList.add('hidden')
                    });
                } else {
                    modal.classList.add('hidden');
                }
            }
        }

        function refreshRoomList() {
            sendMessage('get_room_list');
            const roomList = document.getElementById('roomList');
            if (roomList) {
                roomList.innerHTML = `
                    <div style="text-align: center; color: #ccc; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 25px; width: 80px; height: 80px;"></div>
                        Fetching royal rooms...
                    </div>
                `;
            }
        }

        function updateRoomList(rooms) {
            const listElement = document.getElementById('roomList');
            if (!listElement) return;

            if (!rooms || rooms.length === 0) {
                listElement.innerHTML = `
                    <div style="text-align: center; color: #ccc; padding: 40px;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">🏛️</div>
                        <div style="font-size: 1.2rem;">No public royal rooms available</div>
                        <div style="font-size: 0.9rem; margin-top: 10px; opacity: 0.7;">Create your own room to start playing!</div>
                    </div>
                `;
                return;
            }

            listElement.innerHTML = rooms.map((room, index) => `
                <div style="background: var(--glass-bg); border-radius: 15px; padding: 20px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; opacity: 0; border: 1px solid rgba(255, 215, 0, 0.3); transition: all 0.3s ease; cursor: pointer;" id="room-${index}" onmouseover="this.style.borderColor='var(--royal-gold)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.borderColor='rgba(255, 215, 0, 0.3)'; this.style.transform='translateY(0)'">
                    <div>
                        <strong style="color: var(--royal-gold); font-size: 1.1rem;">${room.name || room.code}</strong>
                        <br>
                        <small style="color: #ccc; font-size: 0.9rem;">
                            👥 Players: ${room.players}/${room.max_players} |
                            🎮 Phase: ${room.phase.replace('_', ' ').toUpperCase()} |
                            🕐 Created: ${room.created}
                        </small>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="premium-button" onclick="joinRoomByCode('${room.code}')" style="min-width: 80px;">Join</button>
                        <button class="premium-button" onclick="spectateRoomByCode('${room.code}')" style="min-width: 80px;">Spectate</button>
                    </div>
                </div>
            `).join('');

            // Animate room entries
            if (typeof gsap !== 'undefined') {
                rooms.forEach((_, index) => {
                    gsap.fromTo(`#room-${index}`,
                        { opacity: 0, x: -50, scale: 0.95 },
                        { opacity: 1, x: 0, scale: 1, duration: 0.5, delay: index * 0.1, ease: "power2.out", overwrite: "auto" }
                    );
                });
            } else {
                rooms.forEach((_, index) => {
                    const roomEl = document.getElementById(`room-${index}`);
                    if (roomEl) roomEl.style.opacity = '1';
                });
            }
        }

        function joinRoomByCode(code) {
            const nameInput = document.getElementById('playerName');
            const name = nameInput ? nameInput.value.trim() : 'Royal Player';
            hideRoomList();
            if (sendMessage('join_room', { room_code: code, player_name: name })) {
                showLoadingScreen('Joining royal room...');
            }
        }

        function spectateRoomByCode(code) {
            hideRoomList();
            if (sendMessage('spectate_room', { room_code: code })) {
                showLoadingScreen('Joining as royal spectator...');
            }
        }

        // Enhanced Notification System
        function showNotification(message, type = 'info', duration = 5000) {
            const container = document.getElementById('notificationContainer');
            if (!container) return;

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            container.appendChild(notification);

            // Enhanced entrance animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(notification,
                    { y: -100, opacity: 0, scale: 0.8, rotationX: -90 },
                    { y: 0, opacity: 1, scale: 1, rotationX: 0, duration: 0.6, ease: "back.out(1.7)" }
                );

                // Auto-remove with enhanced exit animation
                setTimeout(() => {
                    gsap.to(notification, {
                        y: -100,
                        opacity: 0,
                        scale: 0.8,
                        rotationX: 90,
                        duration: 0.5,
                        ease: "power2.in",
                        onComplete: () => notification.remove()
                    });
                }, duration);
            } else {
                setTimeout(() => {
                    notification.remove();
                }, duration);
            }
        }

        // Enhanced Event Listeners
        window.addEventListener('resize', function() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                consoleLog("Window resized - updated renderer");
            }
             // Re-evaluate betting panel position on resize for mobile responsiveness
            if (window.innerWidth <= 768) {
                const betPanel = document.getElementById('betControls');
                if (betPanel && !betPanel.classList.contains('hidden')) {
                    betPanel.style.left = '50%';
                    betPanel.style.transform = 'translateX(-50%)';
                }
            } else {
                const betPanel = document.getElementById('betControls');
                 if (betPanel && !betPanel.classList.contains('hidden')) {
                    betPanel.style.left = '30px';
                    betPanel.style.transform = 'none';
                }
            }
        });

        document.addEventListener('keydown', function(event) {
            // Don't handle if focused on input
            if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                return;
            }

            if (!currentGameState || !currentGameState.can_act || !currentGameState.available_actions) return;

            const actions = currentGameState.available_actions.map(a => a.action);
            const keyActions = {
                'h': 'hit',
                's': 'stand',
                'd': 'double_down',
                'p': 'split',
                'r': 'surrender'
            };

            const action = keyActions[event.key.toLowerCase()];
            if (action && actions.includes(action)) {
                playerAction(action);
            }
        });

        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                consoleLog("Page hidden - reducing activity");
            } else {
                consoleLog("Page visible - resuming activity");
                if (!isConnected && !isLoadingOrReconnecting) {
                    consoleLog("Reconnecting on page visibility");
                    connectWebSocket();
                }
            }
        });

        window.addEventListener('error', function(event) {
            consoleError('Global error:', event.message, 'at', event.filename, ':', event.lineno);
            showNotification('⚠️ An error occurred. Please refresh if issues persist.', 'error', 8000);
        });

        window.addEventListener('unhandledrejection', function(event) {
            consoleError('Unhandled promise rejection:', event.reason);
            showNotification('⚠️ Unexpected error occurred.', 'error', 6000);
        });

        // Enhanced Application Initialization
        window.addEventListener('load', async function() {
            consoleLog("🎰 Royal Blackjack 3D initializing...");
            const loadingTextEl = document.getElementById('loadingScreen')?.querySelector('.loading-text');

            if (!loadingTextEl) {
                consoleError("Loading text element not found");
                alert("Initialization error - please refresh the page.");
                return;
            }

            try {
                loadingTextEl.textContent = "Loading premium libraries...";

                // Check Three.js availability
                const threeAvailable = await checkThreeJS();

                // Verify GSAP
                if (typeof gsap === 'undefined') {
                    consoleWarn("GSAP library not available, animations will be limited");
                }

                if (threeAvailable && window.WEBGL_SUPPORTED) {
                    loadingTextEl.textContent = "Initializing 3D engine...";
                    const engineSuccess = await initThreeJS();
                    if (!engineSuccess) {
                        throw new Error("3D engine initialization failed");
                    }
                } else {
                    consoleLog("3D not available, using 2D fallback mode");
                    enable2DFallback();
                }

                loadingTextEl.textContent = "Connecting to royal servers...";
                connectWebSocket();

                // Create floating particles for visual appeal
                createFloatingParticles();

                consoleLog("🎰 Royal Blackjack 3D initialization sequence completed successfully");

            } catch (e) {
                consoleError("Initialization error:", e);
                loadingTextEl.textContent = "Error: " + e.message;

                showNotification("⚠️ Initialization failed: " + e.message, "error", 15000);
                updateConnectionStatus('disconnected', e.message);

                // Enable 2D fallback on any initialization error
                setTimeout(() => {
                    enable2DFallback();
                    hideLoadingScreen();
                    showMainMenu();
                }, 3000);
            }
        });

        window.addEventListener('beforeunload', function() {
            consoleLog("🎰 Royal Blackjack 3D shutting down...");
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, "Page unload");
            }
        });

        // Add royal flair with periodic effects
        setInterval(() => {
            if (Math.random() < 0.1) { // 10% chance every interval
                // Create a subtle golden sparkle effect
                const sparkle = document.createElement('div');
                sparkle.style.position = 'fixed';
                sparkle.style.left = Math.random() * 100 + '%';
                sparkle.style.top = Math.random() * 100 + '%';
                sparkle.style.width = '4px';
                sparkle.style.height = '4px';
                sparkle.style.background = 'radial-gradient(circle, #ffd700, transparent)';
                sparkle.style.borderRadius = '50%';
                sparkle.style.pointerEvents = 'none';
                sparkle.style.zIndex = '1';
                document.body.appendChild(sparkle);

                if (typeof gsap !== 'undefined') {
                    gsap.to(sparkle, {
                        opacity: 0,
                        scale: 3,
                        duration: 2,
                        ease: "power2.out",
                        onComplete: () => sparkle.remove()
                    });
                } else {
                    setTimeout(() => sparkle.remove(), 2000);
                }
            }
        }, 2000);

        // Fix input focus issues
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure all inputs are properly focusable
            const inputs = document.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                input.addEventListener('focus', function() {
                    this.style.outline = 'none';
                    this.style.userSelect = 'text';
                });

                input.addEventListener('click', function(e) {
                    e.stopPropagation();
                    this.focus();
                });
            });
        });

        consoleLog("🎰 Royal Blackjack 3D script loaded and ready for initialization");
    </script>
</body>
</html>
